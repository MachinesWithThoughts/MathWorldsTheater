<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Set Explorer</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-gradient-start: #0f172a;
        --bg-gradient-end: #020617;
        --panel-bg: rgba(15, 23, 42, 0.82);
        --panel-border: rgba(148, 163, 184, 0.1);
        --text-primary: #e2e8f0;
        --text-muted: #94a3b8;
        --accent: #38bdf8;
        --control-bg: rgba(30, 41, 59, 0.8);
        --control-border: rgba(148, 163, 184, 0.2);
        --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.35);
      }

      html,
      body {
        height: 100%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
        color: var(--text-primary);
      }

      #app {
        display: grid;
        grid-template-columns: minmax(240px, 320px) minmax(0, 1fr);
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 24px;
        background: var(--panel-bg);
        border-right: 1px solid var(--panel-border);
        backdrop-filter: blur(18px);
        overflow-y: auto;
        box-shadow: var(--shadow-soft);
      }

      .controls-panel h1 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
      }

      .controls-panel p.description {
        margin: 0;
        font-size: 14px;
        color: var(--text-muted);
      }

      .controls-grid {
        display: grid;
        gap: 12px;
      }

      .controls-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        background: var(--control-bg);
        border: 1px solid var(--control-border);
        border-radius: 12px;
        box-shadow: var(--shadow-soft);
      }

      .controls-section h2 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
        background: rgba(56, 189, 248, 0.1);
        color: var(--accent);
        border: 1px solid rgba(56, 189, 248, 0.22);
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      button.control-button {
        appearance: none;
        border: 1px solid var(--control-border);
        background: rgba(3, 7, 18, 0.4);
        color: var(--text-primary);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: transform 160ms ease, background 160ms ease, border-color 160ms ease;
      }

      button.control-button:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        background: rgba(56, 189, 248, 0.1);
      }

      button.control-button:active {
        transform: translateY(0);
        background: rgba(14, 165, 233, 0.22);
      }

      .canvas-stage {
        position: relative;
        overflow: hidden;
        background: radial-gradient(circle at top left, #1e293b 0%, #020617 80%);
      }

      .stage-inner {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas.render-surface {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script>
      (function () {
        function setupApp({ title, description }) {
          const root = document.getElementById("app");
          const controlsPanel = document.createElement("aside");
          controlsPanel.className = "controls-panel";

          const heading = document.createElement("h1");
          heading.textContent = title;
          controlsPanel.appendChild(heading);

          if (description) {
            const para = document.createElement("p");
            para.className = "description";
            para.textContent = description;
            controlsPanel.appendChild(para);
          }

          const controlStack = document.createElement("div");
          controlStack.className = "controls-grid";
          controlsPanel.appendChild(controlStack);

          const stage = document.createElement("section");
          stage.className = "canvas-stage";
          const stageInner = document.createElement("div");
          stageInner.className = "stage-inner";
          stage.appendChild(stageInner);

          root.appendChild(controlsPanel);
          root.appendChild(stage);

          return { controlStack, stageInner };
        }

        function createControlsSection(title, note) {
          const section = document.createElement("section");
          section.className = "controls-section";
          const heading = document.createElement("h2");
          heading.textContent = title;
          section.appendChild(heading);
          if (note) {
            const para = document.createElement("p");
            para.className = "note";
            para.textContent = note;
            section.appendChild(para);
          }
          return section;
        }

        function createButton(label, onClick) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "control-button";
          button.textContent = label;
          button.addEventListener("click", onClick);
          return button;
        }

        function createSlider({ label, min = 0, max = 1000, step = 1, value = 0, onChange }) {
          const wrapper = document.createElement("label");
          wrapper.className = "slider";
          const title = document.createElement("span");
          title.textContent = label;
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = String(min);
          slider.max = String(max);
          slider.step = String(step);
          slider.value = String(value);
          const valueLabel = document.createElement("span");
          valueLabel.className = "value";
          valueLabel.textContent = String(value);
          slider.addEventListener("input", (event) => {
            const newValue = Number(event.target.value);
            valueLabel.textContent = String(newValue);
            if (onChange) onChange(newValue);
          });
          wrapper.appendChild(title);
          wrapper.appendChild(slider);
          wrapper.appendChild(valueLabel);
          return { wrapper, slider, valueLabel };
        }

        function observeElementSize(element, callback) {
          const notify = ({ width, height }) => {
            if (width === 0 || height === 0) return;
            callback({ width, height });
          };

          if (typeof ResizeObserver !== "undefined") {
            const observer = new ResizeObserver((entries) => {
              entries.forEach((entry) => {
                const { width, height } = entry.contentRect;
                notify({ width, height });
              });
            });
            observer.observe(element);
          } else {
            window.addEventListener("resize", () => {
              const rect = element.getBoundingClientRect();
              notify({ width: rect.width, height: rect.height });
            });
          }

          requestAnimationFrame(() => {
            const rect = element.getBoundingClientRect();
            notify({ width: rect.width, height: rect.height });
          });
        }

        const params = {
          centerX: -0.5,
          centerY: 0,
          scale: 3,
          maxIterations: 200,
          smoothing: true,
        };

        const state = {
          width: 800,
          height: 600,
          boundingBox: null,
          dragging: false,
          dragStart: null,
          dragEnd: null,
          renderedImage: null,
        };

        const { controlStack, stageInner } = setupApp({
          title: "Mandelbrot Set Explorer",
          description: "Zoom and pan around the Mandelbrot set. Drag to preview a bounding box before zooming.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);
        const ctx = canvas.getContext("2d", { alpha: false });

        function colorize(iteration, maxIterations) {
          if (iteration >= maxIterations) {
            return [12, 20, 33];
          }

          const t = iteration / maxIterations;
          const r = Math.floor(9 * (1 - t) * t * t * t * 255);
          const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
          const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
          return [r, g, b];
        }

        function renderMandelbrot() {
          const image = ctx.createImageData(state.width, state.height);
          const data = image.data;
          const maxIterations = params.maxIterations;

          for (let y = 0; y < state.height; y += 1) {
            const cy = params.centerY + (y / state.height - 0.5) * params.scale;
            for (let x = 0; x < state.width; x += 1) {
              const cx = params.centerX + (x / state.width - 0.5) * params.scale * (state.width / state.height);
              let zx = 0;
              let zy = 0;
              let iteration = 0;
              while (zx * zx + zy * zy <= 4 && iteration < maxIterations) {
                const xtemp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = xtemp;
                iteration += 1;
              }

              const [r, g, b] = colorize(iteration, maxIterations);
              const index = (y * state.width + x) * 4;
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = 255;
            }
          }

          ctx.putImageData(image, 0, 0);
          state.renderedImage = image;
          if (state.boundingBox) {
            drawBoundingBox(state.boundingBox.start, state.boundingBox.end);
          }
        }

        function screenToComplex(point) {
          return {
            x: params.centerX + (point.x / state.width - 0.5) * params.scale * (state.width / state.height),
            y: params.centerY + (point.y / state.height - 0.5) * params.scale,
          };
        }

        function handleZoomBox(start, end) {
          const minX = Math.min(start.x, end.x);
          const minY = Math.min(start.y, end.y);
          const maxX = Math.max(start.x, end.x);
          const maxY = Math.max(start.y, end.y);

          const startComplex = screenToComplex({ x: minX, y: minY });
          const endComplex = screenToComplex({ x: maxX, y: maxY });

          params.centerX = (startComplex.x + endComplex.x) / 2;
          params.centerY = (startComplex.y + endComplex.y) / 2;
          params.scale = Math.max(
            Math.abs(endComplex.x - startComplex.x),
            Math.abs(endComplex.y - startComplex.y) * (state.width / state.height),
          );
          renderMandelbrot();
        }

        function drawBoundingBox(start, end) {
          const minX = Math.min(start.x, end.x);
          const minY = Math.min(start.y, end.y);
          const maxX = Math.max(start.x, end.x);
          const maxY = Math.max(start.y, end.y);

          ctx.save();
          ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          ctx.setLineDash([6, 4]);
          ctx.lineWidth = 2;
          ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
          ctx.restore();
        }

        canvas.addEventListener("pointerdown", (event) => {
          const rect = canvas.getBoundingClientRect();
          const start = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
          state.dragging = true;
          state.dragStart = start;
          state.dragEnd = start;
          state.boundingBox = { start, end: start };
          if (state.renderedImage) {
            ctx.putImageData(state.renderedImage, 0, 0);
          }
          drawBoundingBox(start, start);
        });

        canvas.addEventListener("pointermove", (event) => {
          if (!state.dragging) return;
          const rect = canvas.getBoundingClientRect();
          const current = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
          state.dragEnd = current;
          state.boundingBox = { start: state.dragStart, end: current };
          if (state.renderedImage) {
            ctx.putImageData(state.renderedImage, 0, 0);
          }
          drawBoundingBox(state.dragStart, current);
        });

        canvas.addEventListener("pointerup", () => {
          if (state.dragging && state.dragStart && state.dragEnd) {
            handleZoomBox(state.dragStart, state.dragEnd);
          }
          state.dragging = false;
          state.dragStart = null;
          state.dragEnd = null;
          state.boundingBox = null;
          renderMandelbrot();
        });

        canvas.addEventListener("pointerleave", () => {
          if (state.dragging) {
            state.dragging = false;
            state.dragStart = null;
            state.dragEnd = null;
            state.boundingBox = null;
            if (state.renderedImage) {
              ctx.putImageData(state.renderedImage, 0, 0);
            }
          }
        });

        canvas.addEventListener("wheel", (event) => {
          event.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const pointer = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
          const zoomFactor = event.deltaY < 0 ? 0.8 : 1.25;
          const pointComplex = screenToComplex(pointer);
          params.centerX = pointComplex.x + (params.centerX - pointComplex.x) * zoomFactor;
          params.centerY = pointComplex.y + (params.centerY - pointComplex.y) * zoomFactor;
          params.scale *= zoomFactor;
          renderMandelbrot();
        }, { passive: false });

        function resetView() {
          params.centerX = -0.5;
          params.centerY = 0;
          params.scale = 3;
          renderMandelbrot();
        }

        const viewControls = createControlsSection("View", "Modify iterations and reset the viewport.");
        const iterationSlider = createSlider({
          label: "Max Iterations",
          min: 50,
          max: 600,
          step: 10,
          value: params.maxIterations,
          onChange: (value) => {
            params.maxIterations = Number(value);
            renderMandelbrot();
          },
        });
        viewControls.appendChild(iterationSlider.wrapper);
        viewControls.appendChild(createButton("Reset View", resetView));
        controlStack.appendChild(viewControls);

        const statusSection = createControlsSection("Status", "Current center and scale.");
        const statusPill = document.createElement("span");
        statusPill.className = "status-pill";
        statusSection.appendChild(statusPill);
        controlStack.appendChild(statusSection);

        function updateStatus() {
          statusPill.textContent = `Center (${params.centerX.toFixed(4)}, ${params.centerY.toFixed(4)}) â€¢ Scale ${params.scale.toFixed(3)}`;
        }

        observeElementSize(stageInner, ({ width, height }) => {
          state.width = Math.floor(width);
          state.height = Math.floor(height);
          canvas.width = state.width;
          canvas.height = state.height;
          renderMandelbrot();
          updateStatus();
        });

        setInterval(updateStatus, 300);
      })();
    </script>
  </body>
</html>

