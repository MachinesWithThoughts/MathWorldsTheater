<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lindenmayer System Explorer</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-gradient-start: #0f172a;
        --bg-gradient-end: #020617;
        --panel-bg: rgba(15, 23, 42, 0.82);
        --panel-border: rgba(148, 163, 184, 0.1);
        --text-primary: #e2e8f0;
        --text-muted: #94a3b8;
        --accent: #38bdf8;
        --control-bg: rgba(30, 41, 59, 0.8);
        --control-border: rgba(148, 163, 184, 0.2);
        --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.35);
      }

      html,
      body {
        height: 100%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
        color: var(--text-primary);
      }

      #app {
        display: grid;
        grid-template-columns: minmax(240px, 320px) minmax(0, 1fr);
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 24px;
        background: var(--panel-bg);
        border-right: 1px solid var(--panel-border);
        backdrop-filter: blur(18px);
        overflow-y: auto;
        box-shadow: var(--shadow-soft);
      }

      .controls-panel h1 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
      }

      .controls-panel p.description {
        margin: 0;
        font-size: 14px;
        color: var(--text-muted);
      }

      .controls-grid {
        display: grid;
        gap: 12px;
      }

      .controls-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        background: var(--control-bg);
        border: 1px solid var(--control-border);
        border-radius: 12px;
        box-shadow: var(--shadow-soft);
      }

      .controls-section h2 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      label.slider {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 13px;
      }

      label.slider span.value {
        font-weight: 600;
        color: var(--accent);
      }

      textarea.control-textarea {
        width: 100%;
        min-height: 120px;
        resize: vertical;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--control-border);
        background: rgba(2, 6, 23, 0.6);
        color: var(--text-primary);
        font-family: "JetBrains Mono", "SFMono-Regular", "Menlo", monospace;
        font-size: 13px;
        line-height: 1.45;
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      button.control-button {
        appearance: none;
        border: 1px solid var(--control-border);
        background: rgba(3, 7, 18, 0.4);
        color: var(--text-primary);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: transform 160ms ease, background 160ms ease, border-color 160ms ease;
      }

      button.control-button:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        background: rgba(56, 189, 248, 0.1);
      }

      button.control-button:active {
        transform: translateY(0);
        background: rgba(14, 165, 233, 0.22);
      }

      .canvas-stage {
        position: relative;
        overflow: hidden;
        background: radial-gradient(circle at top left, #1e293b 0%, #020617 80%);
      }

      .stage-inner {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas.render-surface {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script>
      (function () {
        function setupApp({ title, description }) {
          const root = document.getElementById("app");
          const controlsPanel = document.createElement("aside");
          controlsPanel.className = "controls-panel";

          const heading = document.createElement("h1");
          heading.textContent = title;
          controlsPanel.appendChild(heading);

          if (description) {
            const para = document.createElement("p");
            para.className = "description";
            para.textContent = description;
            controlsPanel.appendChild(para);
          }

          const controlStack = document.createElement("div");
          controlStack.className = "controls-grid";
          controlsPanel.appendChild(controlStack);

          const stage = document.createElement("section");
          stage.className = "canvas-stage";
          const stageInner = document.createElement("div");
          stageInner.className = "stage-inner";
          stage.appendChild(stageInner);

          root.appendChild(controlsPanel);
          root.appendChild(stage);

          return { controlStack, stageInner };
        }

        function createControlsSection(title, note) {
          const section = document.createElement("section");
          section.className = "controls-section";
          const heading = document.createElement("h2");
          heading.textContent = title;
          section.appendChild(heading);
          if (note) {
            const para = document.createElement("p");
            para.className = "note";
            para.textContent = note;
            section.appendChild(para);
          }
          return section;
        }

        function createButton(label, onClick) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "control-button";
          button.textContent = label;
          button.addEventListener("click", onClick);
          return button;
        }

        function createSlider({ label, min = 0, max = 100, step = 1, value = 0, onChange }) {
          const wrapper = document.createElement("label");
          wrapper.className = "slider";
          const title = document.createElement("span");
          title.textContent = label;
          const slider = document.createElement("input");
          slider.type = "range";
          slider.min = String(min);
          slider.max = String(max);
          slider.step = String(step);
          slider.value = String(value);
          const valueLabel = document.createElement("span");
          valueLabel.className = "value";
          valueLabel.textContent = String(value);
          slider.addEventListener("input", (event) => {
            const newValue = Number(event.target.value);
            valueLabel.textContent = String(newValue);
            if (onChange) onChange(newValue);
          });
          wrapper.appendChild(title);
          wrapper.appendChild(slider);
          wrapper.appendChild(valueLabel);
          return { wrapper, slider, valueLabel };
        }

        function createTextarea({ label, value = "", onChange }) {
          const wrapper = document.createElement("label");
          wrapper.className = "slider";
          const title = document.createElement("span");
          title.textContent = label;
          const textarea = document.createElement("textarea");
          textarea.className = "control-textarea";
          textarea.value = value;
          textarea.addEventListener("input", (event) => {
            if (onChange) onChange(event.target.value);
          });
          wrapper.appendChild(title);
          wrapper.appendChild(textarea);
          return { wrapper, textarea };
        }

        function observeElementSize(element, callback) {
          const notify = ({ width, height }) => {
            if (width === 0 || height === 0) return;
            callback({ width, height });
          };

          if (typeof ResizeObserver !== "undefined") {
            const observer = new ResizeObserver((entries) => {
              entries.forEach((entry) => {
                const { width, height } = entry.contentRect;
                notify({ width, height });
              });
            });
            observer.observe(element);
          } else {
            window.addEventListener("resize", () => {
              const rect = element.getBoundingClientRect();
              notify({ width: rect.width, height: rect.height });
            });
          }

          requestAnimationFrame(() => {
            const rect = element.getBoundingClientRect();
            notify({ width: rect.width, height: rect.height });
          });
        }

        const presets = {
          Koch: {
            axiom: "F",
            rules: "F=F+F--F+F",
            angle: 60,
            iterations: 4,
            length: 8,
          },
          Dragon: {
            axiom: "FX",
            rules: "X=X+YF+\nY=-FX-Y",
            angle: 90,
            iterations: 10,
            length: 6,
          },
          Plant: {
            axiom: "X",
            rules: "X=F+[[X]-X]-F[-FX]+X\nF=FF",
            angle: 25,
            iterations: 5,
            length: 7,
          },
        };

        const state = {
          axiom: presets.Koch.axiom,
          rulesText: presets.Koch.rules,
          angle: presets.Koch.angle,
          iterations: presets.Koch.iterations,
          segmentLength: presets.Koch.length,
          path: [],
        };

        const { controlStack, stageInner } = setupApp({
          title: "Lindenmayer System Explorer",
          description: "Edit the grammar and parameters to visualize different L-systems.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);
        const ctx = canvas.getContext("2d");

        function parseRules(text) {
          const lines = text
            .split(/\n+/)
            .map((line) => line.trim())
            .filter(Boolean);
          const rules = new Map();
          lines.forEach((line) => {
            const [lhs, rhs] = line.split("=");
            if (lhs && rhs) {
              rules.set(lhs.trim(), rhs.trim());
            }
          });
          return rules;
        }

        function generateSequence() {
          let sequence = state.axiom;
          const rules = parseRules(state.rulesText);
          for (let i = 0; i < state.iterations; i += 1) {
            let next = "";
            for (const char of sequence) {
              next += rules.get(char) ?? char;
            }
            sequence = next;
          }
          return sequence;
        }

        function renderPath() {
          const instructions = generateSequence();
          const pos = { x: 0, y: 0 };
          let angle = -Math.PI / 2;
          const stack = [];
          const vertices = [];
          const segmentLength = state.segmentLength;
          const angleStep = (state.angle * Math.PI) / 180;
          vertices.push({ x: pos.x, y: pos.y });
          for (const token of instructions) {
            switch (token) {
              case "F":
              case "G": {
                pos.x += Math.cos(angle) * segmentLength;
                pos.y += Math.sin(angle) * segmentLength;
                vertices.push({ x: pos.x, y: pos.y });
                break;
              }
              case "+": {
                angle += angleStep;
                break;
              }
              case "-": {
                angle -= angleStep;
                break;
              }
              case "[": {
                stack.push({ x: pos.x, y: pos.y, angle });
                break;
              }
              case "]": {
                const saved = stack.pop();
                if (saved) {
                  pos.x = saved.x;
                  pos.y = saved.y;
                  angle = saved.angle;
                  vertices.push({ move: true, x: pos.x, y: pos.y });
                }
                break;
              }
              default:
                break;
            }
          }
          state.path = vertices;
        }

        function draw() {
          const { width, height } = canvas;
          ctx.fillStyle = "rgba(2, 6, 23, 0.94)";
          ctx.fillRect(0, 0, width, height);

          if (!state.path.length) {
            renderPath();
          }

          if (!state.path.length) return;

          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;

          state.path.forEach((point) => {
            if (point.move) return;
            minX = Math.min(minX, point.x);
            minY = Math.min(minY, point.y);
            maxX = Math.max(maxX, point.x);
            maxY = Math.max(maxY, point.y);
          });

          const padding = 32;
          const pathWidth = maxX - minX || 1;
          const pathHeight = maxY - minY || 1;

          const scale = Math.min(
            (width - padding * 2) / pathWidth,
            (height - padding * 2) / pathHeight,
          );

          const offsetX = (width - pathWidth * scale) / 2 - minX * scale;
          const offsetY = (height - pathHeight * scale) / 2 - minY * scale;

          ctx.strokeStyle = "rgba(56, 189, 248, 0.85)";
          ctx.lineWidth = 2;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";

          ctx.beginPath();
          let first = true;
          state.path.forEach((point) => {
            if (point.move) {
              ctx.moveTo(point.x * scale + offsetX, point.y * scale + offsetY);
              first = true;
            } else {
              const x = point.x * scale + offsetX;
              const y = point.y * scale + offsetY;
              if (first) {
                ctx.moveTo(x, y);
                first = false;
              } else {
                ctx.lineTo(x, y);
              }
            }
          });
          ctx.stroke();
        }

        function updatePath() {
          state.path = [];
          renderPath();
          draw();
        }

        const grammarSection = createControlsSection("Grammar", "Edit the axiom and production rules.");
        const axiomInput = createTextarea({
          label: "Axiom",
          value: state.axiom,
          onChange: (value) => {
            state.axiom = value.trim();
            updatePath();
          },
        });
        const rulesInput = createTextarea({
          label: "Rules (A=AB per line)",
          value: state.rulesText,
          onChange: (value) => {
            state.rulesText = value;
            updatePath();
          },
        });
        grammarSection.appendChild(axiomInput.wrapper);
        grammarSection.appendChild(rulesInput.wrapper);
        controlStack.appendChild(grammarSection);

        const parameters = createControlsSection("Parameters", "Adjust angle, iterations, and segment length.");
        const angleSlider = createSlider({
          label: "Angle",
          min: 0,
          max: 180,
          value: state.angle,
          onChange: (value) => {
            state.angle = Number(value);
            updatePath();
          },
        });
        const iterationsSlider = createSlider({
          label: "Iterations",
          min: 0,
          max: 10,
          value: state.iterations,
          onChange: (value) => {
            state.iterations = Number(value);
            updatePath();
          },
        });
        const lengthSlider = createSlider({
          label: "Segment Length",
          min: 1,
          max: 20,
          value: state.segmentLength,
          onChange: (value) => {
            state.segmentLength = Number(value);
            updatePath();
          },
        });
        parameters.appendChild(angleSlider.wrapper);
        parameters.appendChild(iterationsSlider.wrapper);
        parameters.appendChild(lengthSlider.wrapper);
        controlStack.appendChild(parameters);

        const presetsSection = createControlsSection("Presets", "Load sample grammars.");
        const buttonRow = document.createElement("div");
        buttonRow.className = "button-row";
        Object.entries(presets).forEach(([name, preset]) => {
          buttonRow.appendChild(
            createButton(name, () => {
              state.axiom = preset.axiom;
              state.rulesText = preset.rules;
              state.angle = preset.angle;
              state.iterations = preset.iterations;
              state.segmentLength = preset.length;
              axiomInput.textarea.value = state.axiom;
              rulesInput.textarea.value = state.rulesText;
              angleSlider.slider.value = String(state.angle);
              angleSlider.valueLabel.textContent = String(state.angle);
              iterationsSlider.slider.value = String(state.iterations);
              iterationsSlider.valueLabel.textContent = String(state.iterations);
              lengthSlider.slider.value = String(state.segmentLength);
              lengthSlider.valueLabel.textContent = String(state.segmentLength);
              updatePath();
            }),
          );
        });
        presetsSection.appendChild(buttonRow);
        controlStack.appendChild(presetsSection);

        observeElementSize(stageInner, ({ width, height }) => {
          canvas.width = width;
          canvas.height = height;
          draw();
        });

        renderPath();
        draw();
      })();
    </script>
  </body>
</html>

