<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voronoi Diagram Explorer</title>
    <link rel="stylesheet" href="../../shared/base.css" />
  </head>
  <body>
    <div id="app"></div>
    <script src="../../shared/ui.js"></script>
    <script src="../../shared/rendering.js"></script>
    <script>
      (function (global) {
        const {
          setupApp,
          createControlsSection,
          createButton,
          createSlider,
          createSelect,
          observeElementSize,
        } = global.MathWorldsUI;
        const { createRenderController } = global.MathWorldsRendering;

        const state = {
          siteCount: 16,
          sites: [],
          draggingIndex: null,
          hoverIndex: null,
          initialized: false,
          renderMode: "euclidean",
          wrapMode: "none",
        };

        const { controlStack, stageInner } = setupApp({
          title: "Voronoi Diagram Explorer",
          description: "Drag the sites to see the Voronoi tessellation update in real-time.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);

        const renderController = createRenderController(canvas, {
          background: "rgba(2, 6, 23, 0.94)",
        });
        renderController.setWrapMode(state.wrapMode);

        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d");

        function randomSites(count) {
          const { width, height } = offscreenCanvas;
          const points = [];
          for (let i = 0; i < count; i += 1) {
            points.push({
              x: Math.random() * width,
              y: Math.random() * height,
            });
          }
          return points;
        }

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function generateVoronoiCells(sites) {
          const { width, height } = offscreenCanvas;
          const polygons = sites.map(() => [
            { x: 0, y: 0 },
            { x: width, y: 0 },
            { x: width, y: height },
            { x: 0, y: height },
          ]);

          const clipPolygon = (polygon, a, b) => {
            const output = [];
            for (let i = 0; i < polygon.length; i += 1) {
              const current = polygon[i];
              const prev = polygon[(i + polygon.length - 1) % polygon.length];
              const sideCurrent = (b.x - a.x) * (current.y - a.y) - (b.y - a.y) * (current.x - a.x);
              const sidePrev = (b.x - a.x) * (prev.y - a.y) - (b.y - a.y) * (prev.x - a.x);

              if (sideCurrent <= 0) {
                if (sidePrev > 0) {
                  const t = sidePrev / (sidePrev - sideCurrent);
                  output.push({
                    x: prev.x + (current.x - prev.x) * t,
                    y: prev.y + (current.y - prev.y) * t,
                  });
                }
                output.push(current);
              } else if (sidePrev <= 0) {
                const t = sidePrev / (sidePrev - sideCurrent);
                output.push({
                  x: prev.x + (current.x - prev.x) * t,
                  y: prev.y + (current.y - prev.y) * t,
                });
              }
            }
            return output;
          };

          for (let i = 0; i < sites.length; i += 1) {
            for (let j = 0; j < sites.length; j += 1) {
              if (i === j) continue;
              const siteI = sites[i];
              const siteJ = sites[j];
              const midX = (siteI.x + siteJ.x) / 2;
              const midY = (siteI.y + siteJ.y) / 2;
              const dx = siteJ.x - siteI.x;
              const dy = siteJ.y - siteI.y;
              const midpoint = { x: midX, y: midY };
              const normal = {
                x: midpoint.x + dy,
                y: midpoint.y - dx,
              };
              const alt = {
                x: midpoint.x - dy,
                y: midpoint.y + dx,
              };
              const polygon = clipPolygon(polygons[i], midpoint, normal);
              if (polygon.length === 0) {
                polygons[i] = clipPolygon(polygons[i], midpoint, alt);
              } else {
                polygons[i] = polygon;
              }
            }
          }

          return polygons;
        }

        function drawScene(targetCtx, { width, height }) {
          const pixelWidth = Math.max(1, Math.round(width));
          const pixelHeight = Math.max(1, Math.round(height));

          if (offscreenCanvas.width !== pixelWidth || offscreenCanvas.height !== pixelHeight) {
            offscreenCanvas.width = pixelWidth;
            offscreenCanvas.height = pixelHeight;
          }

          const ctx = offscreenCtx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, pixelWidth, pixelHeight);

          if (!state.sites.length) {
            return;
          }

          const cells = generateVoronoiCells(state.sites);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(15, 23, 42, 0.9)";

          for (let i = 0; i < cells.length; i += 1) {
            const cell = cells[i];
            if (cell.length < 3) continue;
            const hue = Math.floor((i / cells.length) * 360);
            ctx.fillStyle = `hsla(${hue}, 60%, 55%, 0.5)`;
            ctx.beginPath();
            ctx.moveTo(cell[0].x, cell[0].y);
            for (let j = 1; j < cell.length; j += 1) {
              ctx.lineTo(cell[j].x, cell[j].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }

          ctx.fillStyle = "#0ea5e9";
          for (let i = 0; i < state.sites.length; i += 1) {
            const site = state.sites[i];
            ctx.beginPath();
            ctx.arc(site.x, site.y, 6, 0, Math.PI * 2);
            ctx.fill();
            if (state.hoverIndex === i) {
              ctx.lineWidth = 3;
              ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
              ctx.stroke();
            }
          }

          targetCtx.drawImage(
            offscreenCanvas,
            0,
            0,
            pixelWidth,
            pixelHeight,
            0,
            0,
            width,
            height,
          );
        }

        function draw() {
          renderController.render((targetCtx, dimensions) => {
            drawScene(targetCtx, dimensions);
          });
        }

        function pickSite(x, y) {
          for (let i = state.sites.length - 1; i >= 0; i -= 1) {
            const site = state.sites[i];
            const dx = site.x - x;
            const dy = site.y - y;
            if (dx * dx + dy * dy <= 64) {
              return i;
            }
          }
          return null;
        }

        function resetSites(count) {
          state.sites = randomSites(count);
          draw();
        }

        canvas.addEventListener("pointerdown", (event) => {
          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const index = pickSite(point.x, point.y);
          state.draggingIndex = index;
          if (index !== null) {
            canvas.setPointerCapture(event.pointerId);
          }
        });

        canvas.addEventListener("pointermove", (event) => {
          const point = renderController.mapEventToScene(event);
          if (!point) {
            state.hoverIndex = null;
            draw();
            return;
          }

          if (state.draggingIndex !== null) {
            const site = state.sites[state.draggingIndex];
            site.x = clamp(point.x, 0, offscreenCanvas.width);
            site.y = clamp(point.y, 0, offscreenCanvas.height);
            draw();
          } else {
            state.hoverIndex = pickSite(point.x, point.y);
            draw();
          }
        });

        canvas.addEventListener("pointerup", (event) => {
          if (state.draggingIndex !== null) {
            canvas.releasePointerCapture(event.pointerId);
          }
          state.draggingIndex = null;
        });

        canvas.addEventListener("pointerleave", () => {
          state.draggingIndex = null;
          state.hoverIndex = null;
          draw();
        });

        const configurationSection = createControlsSection(
          "Configuration",
          "Adjust site count and regenerate the diagram.",
        );
        const configuration = configurationSection.element;
        const slider = createSlider({
          label: "Number of Sites",
          min: 3,
          max: 64,
          step: 1,
          value: state.siteCount,
          onChange: (value) => {
            state.siteCount = value;
            resetSites(state.siteCount);
          },
        });
        configurationSection.appendChild(slider.wrapper);
        configurationSection.appendChild(
          createButton("Regenerate", () => {
            resetSites(state.siteCount);
          }),
        );
        controlStack.appendChild(configuration);

        const interactionSection = createControlsSection(
          "Interaction",
          "Drag site nodes to update the tessellation.",
        );
        const interaction = interactionSection.element;
        const buttonRow = document.createElement("div");
        buttonRow.className = "button-row";
        buttonRow.appendChild(
          createButton("Scatter New Sites", () => {
            resetSites(state.siteCount);
          }),
        );
        interactionSection.appendChild(buttonRow);
        controlStack.appendChild(interaction);

        const renderingSectionWrapper = createControlsSection(
          "Rendering",
          "Switch between Euclidean and spherical projections. Right-drag in spherical mode to rotate.",
        );
        const renderingSection = renderingSectionWrapper.element;
        const modeSelect = createSelect({
          label: "Mode",
          options: [
            { value: "euclidean", label: "Euclidean" },
            { value: "spherical", label: "Spherical" },
          ],
          value: state.renderMode,
          onChange: (value) => {
            state.renderMode = value;
            renderController.setMode(value);
            if (value === "spherical") {
              renderController.setWrapMode("full");
            } else {
              renderController.setWrapMode(state.wrapMode);
            }
            syncRenderingControls();
            draw();
          },
        });
        const wrapSelect = createSelect({
          label: "Euclidean Wrap",
          options: [
            { value: "none", label: "None" },
            { value: "horizontal", label: "Left-Right" },
            { value: "vertical", label: "Up-Down" },
            { value: "full", label: "Full" },
          ],
          value: state.wrapMode,
          onChange: (value) => {
            state.wrapMode = value;
            renderController.setWrapMode(value);
            draw();
          },
        });
        const resetRotationButton = createButton("Reset Rotation", () => {
          renderController.resetRotation();
          draw();
        });
        renderingSectionWrapper.appendChild(modeSelect.wrapper);
        renderingSectionWrapper.appendChild(wrapSelect.wrapper);
        renderingSectionWrapper.appendChild(resetRotationButton);
        controlStack.appendChild(renderingSection);

        function syncRenderingControls() {
          modeSelect.select.value = state.renderMode;
          wrapSelect.select.value = state.wrapMode;
          const disabled = state.renderMode === "spherical";
          wrapSelect.select.disabled = disabled;
          wrapSelect.wrapper.style.opacity = disabled ? "0.6" : "";
        }

        syncRenderingControls();

        function handleResize({ width, height }) {
          if (!width || !height) {
            return;
          }

          renderController.resize(width, height);
          draw();

          if (!state.initialized) {
            state.initialized = true;
            resetSites(state.siteCount);
          }
        }

        observeElementSize(stageInner, (dimensions) => {
          handleResize(dimensions);
        });

        renderController.onChange(() => {
          draw();
        });

        requestAnimationFrame(() => {
          const rect = stageInner.getBoundingClientRect();
          handleResize({ width: rect.width, height: rect.height });
        });
      })(window);
    </script>
  </body>
</html>

