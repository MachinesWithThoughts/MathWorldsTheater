<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game of Life Explorer</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-gradient-start: #0f172a;
        --bg-gradient-end: #020617;
        --panel-bg: rgba(15, 23, 42, 0.82);
        --panel-border: rgba(148, 163, 184, 0.1);
        --text-primary: #e2e8f0;
        --text-muted: #94a3b8;
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --control-bg: rgba(30, 41, 59, 0.8);
        --control-border: rgba(148, 163, 184, 0.2);
        --control-hover: rgba(148, 163, 184, 0.25);
        --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.35);
        --age-color-young: #38bdf8;
        --age-color-old: #f97316;
        --panel-highlight: rgba(148, 163, 184, 0.45);
      }

      html,
      body {
        height: 100%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
        color: var(--text-primary);
      }

      #app {
        display: grid;
        grid-template-columns: minmax(240px, 320px) minmax(0, 1fr);
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 24px;
        background: var(--panel-bg);
        border-right: 1px solid var(--panel-border);
        backdrop-filter: blur(18px);
        overflow-y: auto;
        box-shadow: var(--shadow-soft);
      }

      .panel-heading {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .panel-version {
        font-size: 12px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(56, 189, 248, 0.15);
        color: var(--accent);
        letter-spacing: 0.02em;
      }

      .controls-panel h1 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
        display: flex;
        align-items: baseline;
        gap: 10px;
      }

      .config-version-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        font-size: 12px;
        font-weight: 500;
        color: var(--accent);
        background: rgba(56, 189, 248, 0.12);
        border: 1px solid rgba(56, 189, 248, 0.35);
        border-radius: 999px;
        letter-spacing: 0.4px;
        text-transform: uppercase;
      }

      .controls-panel p.description {
        margin: 0;
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.5;
      }

      .controls-grid {
        display: grid;
        gap: 12px;
      }

      .controls-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        background: var(--control-bg);
        border: 1px solid var(--control-border);
        border-radius: 12px;
        box-shadow: var(--shadow-soft);
        position: relative;
        transition: border-color 160ms ease, background 160ms ease;
      }

      .controls-section.collapsed {
        border-color: rgba(148, 163, 184, 0.1);
        background: rgba(9, 14, 23, 0.7);
      }

      .section-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: transparent;
        border: none;
        color: inherit;
        padding: 0;
        font: inherit;
        cursor: pointer;
        text-align: left;
      }

      .section-toggle:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .section-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
      }

      .section-toggle-icon {
        flex-shrink: 0;
        width: 18px;
        height: 18px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.2);
        color: var(--accent);
        font-size: 12px;
        transition: transform 160ms ease;
      }

      .controls-section.collapsed .section-toggle-icon {
        transform: rotate(-90deg);
      }

      .section-content {
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow: hidden;
        transition: max-height 200ms ease, opacity 200ms ease, visibility 200ms ease;
      }

      .controls-section.collapsed .section-content {
        max-height: 0;
        opacity: 0;
        visibility: hidden;
      }

      .controls-section h2 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      .controls-section p.note {
        margin: 0;
        font-size: 13px;
        color: var(--text-muted);
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      button.control-button {
        appearance: none;
        border: 1px solid var(--control-border);
        background: rgba(3, 7, 18, 0.4);
        color: var(--text-primary);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: transform 160ms ease, background 160ms ease, border-color 160ms ease;
      }

      button.control-button:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        background: rgba(56, 189, 248, 0.1);
      }

      button.control-button:active {
        transform: translateY(0);
        background: rgba(14, 165, 233, 0.22);
      }

      label.slider {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 13px;
      }

      label.slider span.value {
        font-weight: 600;
        color: var(--accent);
      }

      table.rule-matrix {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
      }

      table.rule-matrix th,
      table.rule-matrix td {
        border: 1px solid rgba(148, 163, 184, 0.25);
        text-align: center;
        padding: 6px 8px;
        font-size: 12px;
      }

      table.rule-matrix td {
        cursor: pointer;
        transition: background 160ms ease, color 160ms ease;
      }

      table.rule-matrix td.active {
        background: rgba(56, 189, 248, 0.22);
        color: var(--text-primary);
        font-weight: 600;
      }

      code.rule-string {
        display: inline-block;
        margin-top: 8px;
        padding: 6px 10px;
        border-radius: 8px;
        background: rgba(15, 23, 42, 0.5);
        border: 1px solid rgba(148, 163, 184, 0.25);
        font-family: "JetBrains Mono", monospace;
        font-size: 13px;
      }

      input[type="range"] {
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.25);
        overflow: hidden;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.35);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        border: none;
        cursor: pointer;
      }

      .canvas-stage {
        position: relative;
        overflow: hidden;
        background: radial-gradient(circle at top left, #1e293b 0%, #020617 80%);
      }

      .stage-inner {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas.render-surface {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
      }

      .cell-history-panel {
        position: absolute;
        top: 24px;
        right: 24px;
        width: min(320px, 40vw);
        max-height: calc(100% - 48px);
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        background: rgba(8, 14, 26, 0.92);
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        box-shadow: 0 18px 40px rgba(2, 6, 23, 0.55);
        backdrop-filter: blur(16px);
        opacity: 0;
        pointer-events: none;
        transform: translateX(12px);
        transition: opacity 180ms ease, transform 180ms ease;
        overflow: hidden;
      }

      .cell-history-panel[data-visible="true"] {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(0);
      }

      .cell-history-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .cell-history-header h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      .cell-history-close {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.6);
        color: var(--text-primary);
        border-radius: 999px;
        width: 28px;
        height: 28px;
        font-size: 14px;
        line-height: 1;
        cursor: pointer;
        transition: background 160ms ease, border-color 160ms ease, transform 160ms ease;
      }

      .cell-history-close:hover {
        background: rgba(56, 189, 248, 0.22);
        border-color: var(--accent);
      }

      .cell-history-summary {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.18);
      }

      .cell-history-summary span {
        font-size: 12px;
        color: var(--text-muted);
      }

      .cell-history-summary strong {
        display: block;
        font-size: 14px;
        color: var(--text-primary);
      }

      .cell-history-timeline {
        flex: 1;
        overflow-y: auto;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.15);
        background: rgba(10, 15, 25, 0.6);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .timeline-entry {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.12);
        background: rgba(17, 24, 39, 0.55);
      }

      .timeline-entry[data-state="alive"] {
        border-color: rgba(56, 189, 248, 0.4);
        background: rgba(56, 189, 248, 0.12);
        color: var(--text-primary);
      }

      .timeline-entry[data-state="dead"] {
        color: var(--text-muted);
      }

      .timeline-meta {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .timeline-age-swatch {
        width: 12px;
        height: 12px;
        border-radius: 4px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(148, 163, 184, 0.15);
      }

      .timeline-age-swatch[data-state="alive"] {
        border-color: rgba(56, 189, 248, 0.6);
      }

      .cell-age-legend {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 10px;
        align-items: center;
      }

      .cell-age-gradient {
        position: relative;
        height: 10px;
        border-radius: 999px;
        background: linear-gradient(90deg, var(--age-color-young), var(--age-color-old));
        border: 1px solid rgba(148, 163, 184, 0.25);
      }

      .cell-age-legend span {
        font-size: 12px;
        color: var(--text-muted);
      }

      .grid-stats {
        display: flex;
        flex-wrap: wrap;
        gap: 6px 12px;
        font-size: 12px;
        color: var(--text-muted);
        border: 1px solid rgba(148, 163, 184, 0.12);
        background: rgba(15, 23, 42, 0.45);
        border-radius: 10px;
        padding: 8px 10px;
      }

      .grid-stats span {
        white-space: nowrap;
      }

      .timeline-empty {
        font-size: 12px;
        color: var(--text-muted);
        text-align: center;
        padding: 12px 0;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script src="../../shared/ui.js"></script>
    <script src="../../shared/rendering.js"></script>
    <script>
      (function (global) {
        const {
          requirementsVersion,
          setupApp,
          createControlsSection,
          createButton,
          createSlider,
          createSelect,
          observeElementSize,
        } = global.MathWorldsUI;
        const { createRenderController } = global.MathWorldsRendering;

        const config = {
          columns: 64,
          rows: 48,
          cellSize: 14,
          minCellSize: 6,
          maxCellSize: 32,
          ageColorMax: 18,
          running: false,
          speed: 6,
          renderMode: "euclidean",
          wrapMode: "none",
          rules: {
            survival: [2, 3],
            birth: [3],
          },
        };

        const state = {
          grid: new Set(),
          cellRecords: new Map(),
          generation: 0,
          timer: null,
          dragMode: null,
          clickMode: "toggle",
          overlay: {
            mode: "none",
            normalizedSites: [],
          },
          selectedCellKey: null,
          ageColorCache: new Map(),
          theme: {
            age: {
              young: { r: 56, g: 189, b: 248 },
              old: { r: 249, g: 115, b: 22 },
            },
            overlay: {
              name: "age",
              young: { r: 56, g: 189, b: 248 },
              old: { r: 249, g: 115, b: 22 },
            },
            highlight: "rgba(148, 163, 184, 0.45)",
          },
        };

        const gridLimits = {
          minColumns: 8,
          maxColumns: 256,
          minRows: 8,
          maxRows: 256,
        };

        const MAX_HISTORY_RENDER = 200;

        let historyPanel;
        let historyTitle;
        let historySummary;
        let historyTimeline;

        const {
          root,
          controlsPanel,
          controlStack,
          stageInner,
        } = setupApp({
          title: "Game of Life Explorer",
          description: "Experiment with Conway's Game of Life. Tap cells to toggle, then run the simulation.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);

        historyPanel = document.createElement("aside");
        historyPanel.className = "cell-history-panel";
        historyPanel.dataset.visible = "false";

        const historyHeader = document.createElement("div");
        historyHeader.className = "cell-history-header";
        historyTitle = document.createElement("h3");
        historyTitle.textContent = "Cell History";
        const closeButton = document.createElement("button");
        closeButton.className = "cell-history-close";
        closeButton.type = "button";
        closeButton.setAttribute("aria-label", "Close cell history");
        closeButton.textContent = "✕";
        closeButton.addEventListener("click", () => {
          state.selectedCellKey = null;
          updateHistoryPanel();
          draw();
        });
        historyHeader.appendChild(historyTitle);
        historyHeader.appendChild(closeButton);

        historySummary = document.createElement("div");
        historySummary.className = "cell-history-summary";

        historyTimeline = document.createElement("div");
        historyTimeline.className = "cell-history-timeline";

        const legend = document.createElement("div");
        legend.className = "cell-age-legend";
        const gradient = document.createElement("div");
        gradient.className = "cell-age-gradient";
        const legendLabel = document.createElement("span");
        legendLabel.textContent = "Young → Old";
        legend.appendChild(gradient);
        legend.appendChild(legendLabel);

        historyPanel.appendChild(historyHeader);
        historyPanel.appendChild(historySummary);
        historyPanel.appendChild(historyTimeline);
        historyPanel.appendChild(legend);
        stageInner.appendChild(historyPanel);

        const renderController = createRenderController(canvas, {
          background: "rgba(15, 23, 42, 0.95)",
        });
        renderController.setWrapMode(config.wrapMode);

        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d", { alpha: false });

        function keyFor(x, y) {
          return `${x},${y}`;
        }

        function parseKey(key) {
          const [x, y] = key.split(",").map(Number);
          return { x, y };
        }

        function updateGridDimensions() {
          const controllerState = renderController.getState();
          const width = controllerState.cssWidth;
          const height = controllerState.cssHeight;
          if (!width || !height) {
            return;
          }

          const columns = clamp(Math.floor(width / config.cellSize), gridLimits.minColumns, gridLimits.maxColumns);
          const rows = clamp(Math.floor(height / config.cellSize), gridLimits.minRows, gridLimits.maxRows);

          if (columns === config.columns && rows === config.rows) {
            return;
          }

          const newGrid = new Set();
          const newRecords = new Map();

          state.grid.forEach((key) => {
            const { x, y } = parseKey(key);
            if (x < columns && y < rows) {
              newGrid.add(keyFor(x, y));
            }
          });

          state.cellRecords.forEach((record, key) => {
            const { x, y } = parseKey(key);
            if (x < columns && y < rows) {
              newRecords.set(keyFor(x, y), record);
            }
          });

          config.columns = columns;
          config.rows = rows;
          state.grid = newGrid;
          state.cellRecords = newRecords;

          if (state.selectedCellKey) {
            const { x, y } = parseKey(state.selectedCellKey);
            if (x >= columns || y >= rows) {
              state.selectedCellKey = null;
            }
          }

          updateHistoryPanel();
          draw();
        }

        function getWrapFlags() {
          if (config.renderMode === "spherical") {
            return { wrapX: true, wrapY: true };
          }
          const wrapMode = config.wrapMode;
          return {
            wrapX: wrapMode === "horizontal" || wrapMode === "full",
            wrapY: wrapMode === "vertical" || wrapMode === "full",
          };
        }

        function normalizeCoordinates(x, y) {
          const { wrapX, wrapY } = getWrapFlags();
          if (wrapX) {
            x = ((x % config.columns) + config.columns) % config.columns;
          } else if (x < 0 || x >= config.columns) {
            return null;
          }

          if (wrapY) {
            y = ((y % config.rows) + config.rows) % config.rows;
          } else if (y < 0 || y >= config.rows) {
            return null;
          }

          return { x, y };
        }

        function locateCell(point) {
          const { cssWidth, cssHeight } = renderController.getState();
          const cellWidth = cssWidth / config.columns;
          const cellHeight = cssHeight / config.rows;
          if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
            return null;
          }
          const rawX = Math.floor(point.x / cellWidth);
          const rawY = Math.floor(point.y / cellHeight);
          return normalizeCoordinates(rawX, rawY);
        }

        function colorWithAlpha(rgbString, alpha) {
          const match = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/i.exec(rgbString ?? "");
          if (!match) {
            return rgbString ?? `rgba(56, 189, 248, ${alpha})`;
          }
          const [, r, g, b] = match;
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function createGradient({ young, old }, age, maxAge = config.ageColorMax) {
          const clampedAge = Math.min(age, maxAge);
          const t = maxAge === 0 ? 0 : clampedAge / maxAge;
          const r = Math.round(lerp(young.r, old.r, t));
          const g = Math.round(lerp(young.g, old.g, t));
          const b = Math.round(lerp(young.b, old.b, t));
          return `rgb(${r}, ${g}, ${b})`;
        }

        function createOverlayPalette(name) {
          switch (name) {
            case "rainbow":
              return {
                name,
                young: { r: 244, g: 63, b: 94 },
                old: { r: 59, g: 130, b: 246 },
              };
            case "reverse-rainbow":
              return {
                name,
                young: { r: 59, g: 130, b: 246 },
                old: { r: 244, g: 63, b: 94 },
              };
            case "age":
            default:
              return {
                name: "age",
                young: { ...state.theme.age.young },
                old: { ...state.theme.age.old },
              };
          }
        }

        function getOverlayColorForKey(key) {
          const defaultFill = `rgba(56, 189, 248, 0.25)`;
          const defaultStroke = `rgba(148, 163, 184, 0.6)`;

          if (!key || !state.cellRecords.has(key)) {
            return {
              fill: defaultFill,
              stroke: defaultStroke,
            };
          }

          const record = state.cellRecords.get(key);
          const age = record?.age ?? 0;
          const palette = state.theme.overlay.name === "age"
            ? { young: state.theme.age.young, old: state.theme.age.old }
            : state.theme.overlay;
          const base = createGradient(palette, age, config.ageColorMax);
          const alive = state.grid.has(key);

          return {
            fill: colorWithAlpha(base, alive ? 0.45 : 0.18),
            stroke: colorWithAlpha(base, alive ? 0.9 : 0.35),
          };
        }

        function neighbors(x, y) {
          let count = 0;
          for (let dx = -1; dx <= 1; dx += 1) {
            for (let dy = -1; dy <= 1; dy += 1) {
              if (dx === 0 && dy === 0) continue;
              const coords = normalizeCoordinates(x + dx, y + dy);
              if (!coords) continue;
              if (state.grid.has(keyFor(coords.x, coords.y))) {
                  count += 1;
              }
            }
          }
          return count;
        }

        function getCellRecord(key) {
          if (!state.cellRecords.has(key)) {
            state.cellRecords.set(key, {
              age: 0,
              history: [],
              lastAliveGeneration: null,
              longestStreak: 0,
              currentStreak: 0,
              toggles: 0,
              lastState: "dead",
            });
          }
          return state.cellRecords.get(key);
        }

        function recordCellState(key, alive, generation = state.generation) {
          const record = getCellRecord(key);
          const stateValue = alive ? "alive" : "dead";
          const previousState = record.lastState ?? "dead";
          const previousAge = record.age;

          if (previousState !== stateValue) {
            record.toggles += 1;
          }

          let entryAge = 0;
          if (stateValue === "alive") {
            record.age = previousState === "alive" ? record.age + 1 : 1;
            record.currentStreak = previousState === "alive" ? record.currentStreak + 1 : 1;
            record.longestStreak = Math.max(record.longestStreak, record.currentStreak);
            record.lastAliveGeneration = generation;
            entryAge = record.age;
          } else {
            entryAge = previousAge;
            record.age = 0;
            record.currentStreak = 0;
          }

          record.lastState = stateValue;

          const lastEntry = record.history[record.history.length - 1];
          if (!lastEntry || lastEntry.generation !== generation) {
            record.history.push({ generation, state: stateValue, age: entryAge });
            if (record.history.length > MAX_HISTORY_RENDER) {
              record.history.shift();
            }
          } else {
            lastEntry.state = stateValue;
            lastEntry.age = entryAge;
          }

          return record;
        }

        function applyCellState(x, y, alive, generation = state.generation) {
          if (x < 0 || y < 0 || x >= config.columns || y >= config.rows) {
            return false;
          }
          const key = keyFor(x, y);
          const currentlyAlive = state.grid.has(key);
          if (currentlyAlive === alive) {
            return false;
          }
          if (alive) {
            state.grid.add(key);
          } else {
            state.grid.delete(key);
          }
          recordCellState(key, alive, generation);
          return true;
        }

        function getAgeColor(age) {
          if (state.ageColorCache.has(age)) {
            return state.ageColorCache.get(age);
          }
          const clampedAge = Math.min(age, config.ageColorMax);
          const t = clampedAge / config.ageColorMax;
          const r = Math.round(lerp(state.theme.age.young.r, state.theme.age.old.r, t));
          const g = Math.round(lerp(state.theme.age.young.g, state.theme.age.old.g, t));
          const b = Math.round(lerp(state.theme.age.young.b, state.theme.age.old.b, t));
          const color = `rgb(${r}, ${g}, ${b})`;
          state.ageColorCache.set(age, color);
          return color;
        }

        function drawScene(targetCtx, { width, height }) {
          const pixelWidth = Math.max(1, Math.round(width));
          const pixelHeight = Math.max(1, Math.round(height));

          if (offscreenCanvas.width !== pixelWidth || offscreenCanvas.height !== pixelHeight) {
            offscreenCanvas.width = pixelWidth;
            offscreenCanvas.height = pixelHeight;
          }

          const ctx = offscreenCtx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, pixelWidth, pixelHeight);
          ctx.fillStyle = "rgba(15, 23, 42, 0.95)";
          ctx.fillRect(0, 0, pixelWidth, pixelHeight);

          const cellWidth = pixelWidth / config.columns;
          const cellHeight = pixelHeight / config.rows;

          ctx.strokeStyle = "rgba(148, 163, 184, 0.08)";
          ctx.lineWidth = 1;

          ctx.beginPath();
          for (let x = 1; x < config.columns; x += 1) {
            const px = x * cellWidth;
            ctx.moveTo(px, 0);
            ctx.lineTo(px, pixelHeight);
          }
          for (let y = 1; y < config.rows; y += 1) {
            const py = y * cellHeight;
            ctx.moveTo(0, py);
            ctx.lineTo(pixelWidth, py);
          }
          ctx.stroke();

          const paddingX = Math.min(2, cellWidth * 0.2);
          const paddingY = Math.min(2, cellHeight * 0.2);
          const drawWidth = Math.max(0, cellWidth - paddingX * 2);
          const drawHeight = Math.max(0, cellHeight - paddingY * 2);

          state.grid.forEach((key) => {
            const [cx, cy] = key.split(",").map(Number);
            const record = getCellRecord(key);
            const left = cx * cellWidth + paddingX;
            const top = cy * cellHeight + paddingY;
            ctx.fillStyle = getAgeColor(record.age);
            ctx.fillRect(left, top, drawWidth, drawHeight);
          });

          if (state.selectedCellKey) {
            const { x: selectedX, y: selectedY } = parseKey(state.selectedCellKey);
            if (selectedX >= 0 && selectedX < config.columns && selectedY >= 0 && selectedY < config.rows) {
              const left = selectedX * cellWidth + paddingX;
              const top = selectedY * cellHeight + paddingY;
              ctx.strokeStyle = state.theme.highlight;
              ctx.lineWidth = Math.max(2, Math.min(drawWidth, drawHeight) * 0.12);
              ctx.strokeRect(left + 1, top + 1, Math.max(0, drawWidth - 2), Math.max(0, drawHeight - 2));
            }
          }

          ctx.fillStyle = "rgba(148, 163, 184, 0.65)";
          ctx.font = "14px 'JetBrains Mono', monospace";
          ctx.textBaseline = "bottom";
          ctx.fillText(`Generation ${state.generation}`, 12, pixelHeight - 12);

          drawOverlay(ctx, pixelWidth, pixelHeight);

          targetCtx.drawImage(
            offscreenCanvas,
            0,
            0,
            pixelWidth,
            pixelHeight,
            0,
            0,
            width,
            height,
          );
        }

        function drawOverlay(ctx, width, height) {
          if (state.overlay.mode === "none") {
            return;
          }

          let points;
          if (state.overlay.mode === "voronoi-live" || state.overlay.mode === "voronoi-live-colored" || state.overlay.mode === "delaunay") {
            points = Array.from(state.grid).map((key, index) => {
              const [col, row] = key.split(",").map(Number);
              return {
                x: (col + 0.5) * (width / config.columns),
                y: (row + 0.5) * (height / config.rows),
                key,
                index,
              };
            });
          } else {
            points = state.overlay.normalizedSites.map((site) => ({
              x: site.x * width,
              y: site.y * height,
            }));
          }

          if (!points.length) {
            return;
          }

          if (state.overlay.mode === "voronoi" || state.overlay.mode === "voronoi-live" || state.overlay.mode === "voronoi-live-colored") {
            const cells = generateVoronoiCells(points, width, height);
            ctx.save();
            ctx.globalAlpha = state.overlay.mode === "voronoi-live-colored" ? 1 : 0.4;
            ctx.lineWidth = 1.5;
            cells.forEach((cell, index) => {
              if (cell.length < 3) return;
              ctx.beginPath();
              ctx.moveTo(cell[0].x, cell[0].y);
              for (let i = 1; i < cell.length; i += 1) {
                ctx.lineTo(cell[i].x, cell[i].y);
              }
              ctx.closePath();
              if (state.overlay.mode === "voronoi-live-colored") {
                const color = getOverlayColorForKey(points[index]?.key);
                ctx.fillStyle = color.fill;
                ctx.strokeStyle = color.stroke;
              } else {
                ctx.fillStyle = "rgba(56, 189, 248, 0.18)";
                ctx.strokeStyle = "rgba(148, 163, 184, 0.4)";
              }
              ctx.fill();
              ctx.stroke();
            });
            ctx.restore();
          } else if (state.overlay.mode === "delaunay") {
            const triangles = triangulateDelaunay(points);
            if (triangles.length) {
              const edgeMap = new Map();

              const registerEdge = (indexA, indexB) => {
                if (indexA == null || indexB == null) {
                  return;
                }
                const low = Math.min(indexA, indexB);
                const high = Math.max(indexA, indexB);
                const key = `${low}-${high}`;
                if (!edgeMap.has(key)) {
                  edgeMap.set(key, [low, high]);
                }
              };

              triangles.forEach(([a, b, c]) => {
                registerEdge(a, b);
                registerEdge(b, c);
                registerEdge(c, a);
              });

              ctx.save();
              ctx.lineWidth = Math.max(1.5, Math.min(width, height) * 0.003);
              ctx.lineCap = "round";

              edgeMap.forEach(([indexA, indexB]) => {
                const source = points[indexA];
                const target = points[indexB];
                if (!source || !target) return;
                const startColor = getOverlayColorForKey(source.key).stroke;
                const endColor = getOverlayColorForKey(target.key).stroke;
                const gradient = ctx.createLinearGradient(source.x, source.y, target.x, target.y);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
              });

              ctx.restore();
            }

            ctx.save();
            ctx.fillStyle = "rgba(15, 23, 42, 0.55)";
            ctx.strokeStyle = "rgba(148, 163, 184, 0.65)";
            ctx.lineWidth = 1;
            points.forEach((point) => {
              ctx.beginPath();
              ctx.arc(point.x, point.y, Math.max(2, Math.min(width, height) * 0.004), 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            });
            ctx.restore();
          }

          if (state.overlay.mode !== "voronoi-live" && state.overlay.mode !== "voronoi-live-colored" && state.overlay.mode !== "delaunay") {
            ctx.save();
            ctx.fillStyle = "#f8fafc";
            ctx.strokeStyle = "rgba(15, 23, 42, 0.8)";
            ctx.lineWidth = 2;
            state.overlay.normalizedSites.forEach((site) => {
              ctx.beginPath();
              ctx.arc(site.x * width, site.y * height, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            });
            ctx.restore();
          }
        }

        function draw() {
          renderController.render((targetCtx, dimensions) => {
            drawScene(targetCtx, dimensions);
          });
        }

        function updateHistoryPanel() {
          if (!state.selectedCellKey) {
            historyPanel.dataset.visible = "false";
            historyTitle.textContent = "Cell History";
            historySummary.innerHTML = "";
            historyTimeline.innerHTML = "";
            return;
          }

          const record = getCellRecord(state.selectedCellKey);
          const { x, y } = parseKey(state.selectedCellKey);
          historyTitle.textContent = `Cell (${x}, ${y})`;
          historySummary.innerHTML = "";

          const summaryItems = [
            { label: "Age", value: record.age },
            { label: "State Toggles", value: record.toggles },
            { label: "Alive Streak", value: record.longestStreak },
            { label: "Last Alive", value: record.lastAliveGeneration ?? "—" },
          ];

          summaryItems.forEach((item) => {
            const wrapper = document.createElement("span");
            wrapper.innerHTML = `<strong>${item.label}</strong>${item.value}`;
            historySummary.appendChild(wrapper);
          });

          historyTimeline.innerHTML = "";
          if (record.history.length === 0) {
            const empty = document.createElement("div");
            empty.className = "timeline-empty";
            empty.textContent = "No history yet. Run the simulation to build timeline.";
            historyTimeline.appendChild(empty);
          } else {
            record.history.forEach((entry) => {
              const timelineEntry = document.createElement("div");
              timelineEntry.className = "timeline-entry";
              timelineEntry.dataset.state = entry.state;
              const meta = document.createElement("span");
              meta.className = "timeline-meta";
              const swatch = document.createElement("span");
              swatch.className = "timeline-age-swatch";
              swatch.dataset.state = entry.state;
              const ageColor = getAgeColor(entry.age ?? 0);
              swatch.style.background = ageColor;
              if (entry.state !== "alive") {
                swatch.style.opacity = "0.45";
              }
              const stateLabel = document.createElement("span");
              stateLabel.textContent = entry.state === "alive" ? "Alive" : "Dead";
              meta.appendChild(swatch);
              meta.appendChild(stateLabel);

              const generationLabel = document.createElement("span");
              generationLabel.textContent = `Generation ${entry.generation}`;

              timelineEntry.appendChild(generationLabel);
              timelineEntry.appendChild(meta);
              historyTimeline.appendChild(timelineEntry);
            });
          }

          historyPanel.dataset.visible = "true";
        }

        function step() {
          const next = new Set();
          const nextRecords = new Map();
          const generation = state.generation + 1;
          const pendingRecords = new Map();
          for (let x = 0; x < config.columns; x += 1) {
            for (let y = 0; y < config.rows; y += 1) {
              const alive = state.grid.has(keyFor(x, y));
              const count = neighbors(x, y);
              if (alive && config.rules.survival.includes(count)) {
                const key = keyFor(x, y);
                next.add(key);
                const record = recordCellState(key, true, generation);
                pendingRecords.set(key, record);
              } else if (!alive && config.rules.birth.includes(count)) {
                const key = keyFor(x, y);
                next.add(key);
                const record = recordCellState(key, true, generation);
                pendingRecords.set(key, record);
              } else if (alive) {
                const key = keyFor(x, y);
                const record = recordCellState(key, false, generation);
                pendingRecords.set(key, record);
              }
            }
          }
          state.grid = next;
          pendingRecords.forEach((record, key) => {
            state.cellRecords.set(key, record);
            nextRecords.set(key, record);
          });
          state.generation = generation;
          updateHistoryPanel();
          draw();
        }

        function run() {
          if (!config.running) return;
          step();
          const delay = Math.max(16, 1200 / config.speed);
          state.timer = setTimeout(() => {
            requestAnimationFrame(run);
          }, delay);
        }

        function stop() {
          config.running = false;
          if (state.timer) {
            clearTimeout(state.timer);
            state.timer = null;
          }
        }

        function toggleRunning() {
          config.running = !config.running;
          if (config.running) {
            run();
            playPauseButton.textContent = "Pause";
          } else {
            stop();
            playPauseButton.textContent = "Play";
          }
        }

        function clearGrid() {
          stop();
          state.grid.clear();
          state.generation = 0;
          playPauseButton.textContent = "Play";
          draw();
        }

        function seedGlider() {
          clearGrid();
          state.grid.add(keyFor(1, 0));
          state.grid.add(keyFor(2, 1));
          state.grid.add(keyFor(0, 2));
          state.grid.add(keyFor(1, 2));
          state.grid.add(keyFor(2, 2));
          draw();
        }

        function seedRandom() {
          clearGrid();
          for (let x = 0; x < config.columns; x += 1) {
            for (let y = 0; y < config.rows; y += 1) {
              if (Math.random() < 0.2) {
                state.grid.add(keyFor(x, y));
              }
            }
          }
          draw();
        }

        function randomSites(count) {
          const sites = [];
          for (let i = 0; i < count; i += 1) {
            sites.push({
              x: Math.random(),
              y: Math.random(),
            });
          }
          return sites;
        }

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function lerp(a, b, t) {
          return a + (b - a) * t;
        }

        function toSceneCoordinates(site) {
          const { cssWidth, cssHeight } = renderController.getState();
          return {
            x: site.x * cssWidth,
            y: site.y * cssHeight,
          };
        }

        function toNormalizedCoordinates(scenePoint) {
          const { cssWidth, cssHeight } = renderController.getState();
          if (cssWidth === 0 || cssHeight === 0) {
            return null;
          }
          return {
            x: clamp(scenePoint.x / cssWidth, 0, 1),
            y: clamp(scenePoint.y / cssHeight, 0, 1),
          };
        }

        function generateVoronoiCells(points, width, height) {
          if (!points.length) return [];

          const polygons = points.map(() => [
            { x: 0, y: 0 },
            { x: width, y: 0 },
            { x: width, y: height },
            { x: 0, y: height },
          ]);

          const clipPolygon = (polygon, a, b) => {
            const output = [];
            for (let i = 0; i < polygon.length; i += 1) {
              const current = polygon[i];
              const prev = polygon[(i + polygon.length - 1) % polygon.length];
              const sideCurrent = (b.x - a.x) * (current.y - a.y) - (b.y - a.y) * (current.x - a.x);
              const sidePrev = (b.x - a.x) * (prev.y - a.y) - (b.y - a.y) * (prev.x - a.x);

              if (sideCurrent <= 0) {
                if (sidePrev > 0) {
                  const t = sidePrev / (sidePrev - sideCurrent);
                  output.push({
                    x: prev.x + (current.x - prev.x) * t,
                    y: prev.y + (current.y - prev.y) * t,
                  });
                }
                output.push(current);
              } else if (sidePrev <= 0) {
                const t = sidePrev / (sidePrev - sideCurrent);
                output.push({
                  x: prev.x + (current.x - prev.x) * t,
                  y: prev.y + (current.y - prev.y) * t,
                });
              }
            }
            return output;
          };

          for (let i = 0; i < points.length; i += 1) {
            const siteI = points[i];
            for (let j = 0; j < points.length; j += 1) {
              if (i === j) continue;
              const siteJ = points[j];
              const midX = (siteI.x + siteJ.x) / 2;
              const midY = (siteI.y + siteJ.y) / 2;
              const dx = siteJ.x - siteI.x;
              const dy = siteJ.y - siteI.y;
              const midpoint = { x: midX, y: midY };
              const normal = {
                x: midpoint.x + dy,
                y: midpoint.y - dx,
              };
              const alt = {
                x: midpoint.x - dy,
                y: midpoint.y + dx,
              };
              const polygon = clipPolygon(polygons[i], midpoint, normal);
              polygons[i] = polygon.length === 0 ? clipPolygon(polygons[i], midpoint, alt) : polygon;
            }
          }

          return polygons;
        }

        function triangulateDelaunay(points) {
          if (points.length < 3) return [];

          const baseVertices = points.map((site, index) => ({ x: site.x, y: site.y, index }));

          let minX = baseVertices[0].x;
          let minY = baseVertices[0].y;
          let maxX = baseVertices[0].x;
          let maxY = baseVertices[0].y;
          for (let i = 1; i < baseVertices.length; i += 1) {
            const { x, y } = baseVertices[i];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }

          const dx = maxX - minX;
          const dy = maxY - minY;
          const deltaMax = Math.max(dx, dy) || 1;
          const midX = (minX + maxX) / 2;
          const midY = (minY + maxY) / 2;

          const superOffset = baseVertices.length;
          const superVertices = [
            { x: midX - 2 * deltaMax, y: midY - deltaMax, index: superOffset },
            { x: midX, y: midY + 2 * deltaMax, index: superOffset + 1 },
            { x: midX + 2 * deltaMax, y: midY - deltaMax, index: superOffset + 2 },
          ];

          const allVertices = baseVertices.concat(superVertices);

          const triangles = [{ a: superOffset, b: superOffset + 1, c: superOffset + 2 }];

          function pointInCircumcircle(triangle, vertex) {
            const a = allVertices[triangle.a];
            const b = allVertices[triangle.b];
            const c = allVertices[triangle.c];
            const ax = a.x - vertex.x;
            const ay = a.y - vertex.y;
            const bx = b.x - vertex.x;
            const by = b.y - vertex.y;
            const cx = c.x - vertex.x;
            const cy = c.y - vertex.y;
            const det = (ax * ax + ay * ay) * (bx * cy - by * cx)
              - (bx * bx + by * by) * (ax * cy - ay * cx)
              + (cx * cx + cy * cy) * (ax * by - ay * bx);
            return det > 0;
          }

          function edgeKey(i1, i2) {
            return i1 < i2 ? `${i1}-${i2}` : `${i2}-${i1}`;
          }

          baseVertices.forEach((vertex) => {
            const vertexIndex = vertex.index;

            const badTriangles = [];
            for (let i = triangles.length - 1; i >= 0; i -= 1) {
              if (pointInCircumcircle(triangles[i], vertex)) {
                badTriangles.push(triangles[i]);
                triangles.splice(i, 1);
              }
            }

            const boundary = new Map();
            badTriangles.forEach((triangle) => {
              const edges = [
                [triangle.a, triangle.b],
                [triangle.b, triangle.c],
                [triangle.c, triangle.a],
              ];
              edges.forEach(([from, to]) => {
                const key = edgeKey(from, to);
                if (boundary.has(key)) {
                  boundary.delete(key);
                } else {
                  boundary.set(key, [from, to]);
                }
              });
            });

            boundary.forEach(([from, to]) => {
              triangles.push({ a: from, b: to, c: vertexIndex });
            });
          });

          const result = [];
          triangles.forEach((triangle) => {
            if (triangle.a >= superOffset || triangle.b >= superOffset || triangle.c >= superOffset) {
              return;
            }
            result.push([triangle.a, triangle.b, triangle.c]);
          });

          return result;
        }

        function locateOverlaySite(point, tolerance = 16) {
          const { cssWidth, cssHeight } = renderController.getState();
          if (!cssWidth || !cssHeight) return null;
          const toleranceSq = tolerance * tolerance;
          for (let i = state.overlay.normalizedSites.length - 1; i >= 0; i -= 1) {
            const site = state.overlay.normalizedSites[i];
            const sx = site.x * cssWidth;
            const sy = site.y * cssHeight;
            const dx = sx - point.x;
            const dy = sy - point.y;
            if (dx * dx + dy * dy <= toleranceSq) {
              return i;
            }
          }
          return null;
        }

        function handleOverlayPointerDown() {
          return false;
        }

        function handleOverlayPointerMove() {
          return false;
        }

        function handleOverlayPointerUp() {}

        let playPauseButton;

        const simulationControlsSection = createControlsSection("Simulation", "Play, pause, or step through generations.");
        const simulationControls = simulationControlsSection.element;
        simulationControls.classList.add("panel-home-section");
        const buttonRow = document.createElement("div");
        buttonRow.className = "button-row";
        playPauseButton = createButton("Play", toggleRunning);
        const stepButton = createButton("Step", () => {
          if (!config.running) {
            step();
          }
        });
        const clearButton = createButton("Clear", clearGrid);
        buttonRow.appendChild(playPauseButton);
        buttonRow.appendChild(stepButton);
        buttonRow.appendChild(clearButton);
        simulationControlsSection.appendChild(buttonRow);

        const speedSlider = createSlider({
          label: "Speed",
          min: 1,
          max: 12,
          value: config.speed,
          onChange: (value) => {
            config.speed = Number(value);
          },
        });
        simulationControlsSection.appendChild(speedSlider.wrapper);
        const cellSizeSlider = createSlider({
          label: "Cell Size",
          min: config.minCellSize,
          max: config.maxCellSize,
          value: config.cellSize,
          onChange: (value) => {
            config.cellSize = Number(value);
            updateGridDimensions();
          },
        });
        simulationControlsSection.appendChild(cellSizeSlider.wrapper);
        const clickModeSelect = createSelect({
          label: "Click Mode",
          options: [
            { value: "toggle", label: "Toggle Cell" },
            { value: "explore", label: "Explore Cells" },
          ],
          value: state.clickMode,
          onChange: (value) => {
            state.clickMode = value;
          },
        });
        simulationControlsSection.appendChild(clickModeSelect.wrapper);
        controlStack.appendChild(simulationControls);

        const seedsSectionWrapper = createControlsSection("Seeds", "Start from classic or random patterns.");
        const seedsSection = seedsSectionWrapper.element;
        const seedButtons = document.createElement("div");
        seedButtons.className = "button-row";
        seedButtons.appendChild(createButton("Glider", seedGlider));
        seedButtons.appendChild(createButton("Random", seedRandom));
        seedsSectionWrapper.appendChild(seedButtons);
        controlStack.appendChild(seedsSection);

        const renderingSectionWrapper = createControlsSection(
          "Rendering",
          "Switch between Euclidean and spherical projections. Right-drag in spherical mode to rotate.",
        );
        const renderingSection = renderingSectionWrapper.element;
        const wrapSelect = createSelect({
          label: "Euclidean Wraparound",
          options: [
            { value: "none", label: "None" },
            { value: "horizontal", label: "Left-Right" },
            { value: "vertical", label: "Up-Down" },
            { value: "full", label: "Full" },
          ],
          value: config.wrapMode,
          onChange: (value) => {
            config.wrapMode = value;
            renderController.setWrapMode(value);
            draw();
          },
        });
        const modeSelect = createSelect({
          label: "Rendering Mode",
          options: [
            { value: "euclidean", label: "Euclidean" },
            { value: "spherical", label: "Spherical" },
          ],
          value: config.renderMode,
          onChange: (value) => {
            config.renderMode = value;
            renderController.setMode(value);
            if (value === "spherical") {
              renderController.setWrapMode("full");
            } else {
              renderController.setWrapMode(config.wrapMode);
            }
            syncRenderingControls();
            draw();
          },
        });
        const resetRotationButton = createButton("Reset Rotation", () => {
          renderController.resetRotation();
          draw();
        });
        renderingSectionWrapper.appendChild(modeSelect.wrapper);
        renderingSectionWrapper.appendChild(wrapSelect.wrapper);
        renderingSectionWrapper.appendChild(resetRotationButton);
        controlStack.appendChild(renderingSection);

        function syncRenderingControls() {
          modeSelect.select.value = config.renderMode;
          wrapSelect.select.value = config.wrapMode;
          const disabled = config.renderMode === "spherical";
          wrapSelect.select.disabled = disabled;
          wrapSelect.wrapper.style.opacity = disabled ? "0.6" : "";
        }

        syncRenderingControls();

        const overlaySectionWrapper = createControlsSection("World Overlay", "Blend live-cell Voronoi or Delaunay overlays.");
        const overlaySection = overlaySectionWrapper.element;
        const overlayModeSelect = createSelect({
          label: "Overlay Mode",
          options: [
            { value: "none", label: "None" },
            { value: "voronoi-live", label: "Voronoi (Live Cells)" },
            { value: "voronoi-live-colored", label: "Voronoi (Live Cells, Colored)" },
            { value: "delaunay", label: "Delaunay" },
          ],
          value: state.overlay.mode,
          onChange: (value) => {
            state.overlay.mode = value;
            draw();
          },
        });
        const overlayThemeSelect = createSelect({
          label: "Overlay Theme",
          options: [
            { value: "age", label: "Match Cell Age" },
            { value: "rainbow", label: "Rainbow" },
            { value: "reverse-rainbow", label: "Rainbow (Reverse)" },
          ],
          value: state.theme.overlay.name,
          onChange: (value) => {
            state.theme.overlay = createOverlayPalette(value);
            draw();
          },
        });
        const overlayButtons = document.createElement("div");
        overlayButtons.className = "button-row";
        overlayButtons.appendChild(createButton("Clear Overlay", () => {
          state.overlay.mode = "none";
          overlayModeSelect.select.value = "none";
          draw();
        }));

        overlaySectionWrapper.appendChild(overlayModeSelect.wrapper);
        overlaySectionWrapper.appendChild(overlayThemeSelect.wrapper);
        overlaySectionWrapper.appendChild(overlayButtons);
        controlStack.appendChild(overlaySection);

        const ruleSectionWrapper = createControlsSection(
          "Rules",
          "Adjust Life-like rule sets; copy or reset to default.",
        );
        const ruleSection = ruleSectionWrapper.element;

        const ruleMatrix = document.createElement("div");
        ruleMatrix.className = "rule-matrix-wrapper";

        const ruleString = document.createElement("code");
        ruleString.className = "rule-string";

        function updateRuleString() {
          const birth = config.rules.birth.slice().sort((a, b) => a - b).join("");
          const survival = config.rules.survival.slice().sort((a, b) => a - b).join("");
          ruleString.textContent = `B${birth.length ? birth : 0}/S${survival.length ? survival : 0}`;
        }

        function renderRuleMatrix() {
          ruleMatrix.innerHTML = "";
          const table = document.createElement("table");
          table.className = "rule-matrix";

          const birthRow = document.createElement("tr");
          const birthLabel = document.createElement("th");
          birthLabel.textContent = "Birth";
          birthRow.appendChild(birthLabel);
          for (let i = 0; i <= 8; i += 1) {
            const td = document.createElement("td");
            td.dataset.mode = "birth";
            td.dataset.value = String(i);
            td.textContent = String(i);
            if (config.rules.birth.includes(i)) {
              td.classList.add("active");
            }
            birthRow.appendChild(td);
          }
          table.appendChild(birthRow);

          const survivalRow = document.createElement("tr");
          const survivalLabel = document.createElement("th");
          survivalLabel.textContent = "Survival";
          survivalRow.appendChild(survivalLabel);
          for (let i = 0; i <= 8; i += 1) {
            const td = document.createElement("td");
            td.dataset.mode = "survival";
            td.dataset.value = String(i);
            td.textContent = String(i);
            if (config.rules.survival.includes(i)) {
              td.classList.add("active");
            }
            survivalRow.appendChild(td);
          }
          table.appendChild(survivalRow);

          ruleMatrix.appendChild(table);
          updateRuleString();
        }

        ruleMatrix.addEventListener("click", (event) => {
          const cell = event.target.closest("td");
          if (!cell) return;
          const mode = cell.dataset.mode;
          const value = Number(cell.dataset.value);
          if (!Number.isFinite(value)) return;

          const list = config.rules[mode];
          const index = list.indexOf(value);
          if (index === -1) {
            list.push(value);
            list.sort((a, b) => a - b);
            cell.classList.add("active");
          } else {
            list.splice(index, 1);
            cell.classList.remove("active");
          }
          updateRuleString();
        });

        const ruleActions = document.createElement("div");
        ruleActions.className = "button-row";
        ruleActions.appendChild(
          createButton("Copy Rule", () => {
            navigator.clipboard?.writeText(ruleString.textContent).catch(() => {});
          }),
        );
        ruleActions.appendChild(
          createButton("Reset Default", () => {
            config.rules.birth = [3];
            config.rules.survival = [2, 3];
            renderRuleMatrix();
            draw();
          }),
        );

        renderRuleMatrix();
        ruleSectionWrapper.appendChild(ruleMatrix);
        ruleSectionWrapper.appendChild(ruleString);
        ruleSectionWrapper.appendChild(ruleActions);
        controlStack.appendChild(ruleSection);

        observeElementSize(stageInner, ({ width, height }) => {
          renderController.resize(width, height);
          updateGridDimensions();
          draw();
        });

        renderController.onChange(draw);

        canvas.addEventListener("pointerdown", (event) => {
          if (handleOverlayPointerDown(event)) {
            return;
          }

          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const coords = locateCell(point);
          if (!coords) {
            if (state.clickMode === "explore") {
              event.preventDefault();
              state.selectedCellKey = null;
              updateHistoryPanel();
              draw();
            }
            return;
          }

          const key = keyFor(coords.x, coords.y);

          if (state.clickMode === "explore") {
            event.preventDefault();
            if (state.selectedCellKey === key) {
              state.selectedCellKey = null;
            } else {
              state.selectedCellKey = key;
              getCellRecord(key);
            }
            updateHistoryPanel();
            draw();
            return;
          }

          if (event.button !== 0) return;

          event.preventDefault();
          const alive = state.grid.has(key);
          state.dragMode = alive ? "erase" : "paint";
          applyCellState(coords.x, coords.y, !alive);
          if (!alive) {
            state.selectedCellKey = key;
          } else if (state.selectedCellKey === key) {
            state.selectedCellKey = null;
          }
          updateHistoryPanel();
          draw();
          canvas.setPointerCapture(event.pointerId);
        });

        canvas.addEventListener("pointermove", (event) => {
          if (handleOverlayPointerMove(event)) {
            return;
          }
          if (!state.dragMode) return;
          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const coords = locateCell(point);
          if (!coords) return;
          const key = keyFor(coords.x, coords.y);
          if (state.dragMode === "paint") {
            if (applyCellState(coords.x, coords.y, true)) {
              state.selectedCellKey = key;
              updateHistoryPanel();
              draw();
            }
          } else if (state.dragMode === "erase") {
            if (applyCellState(coords.x, coords.y, false)) {
              if (state.selectedCellKey === key) {
                state.selectedCellKey = null;
                updateHistoryPanel();
              }
              draw();
            }
          }
        });

        function endPaint(event) {
          if (state.dragMode && canvas.hasPointerCapture && canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
          }
          state.dragMode = null;
        }

        canvas.addEventListener("pointerup", endPaint);
        canvas.addEventListener("pointercancel", endPaint);
        canvas.addEventListener("pointerleave", endPaint);

        draw();
      })(window);
    </script>
  </body>
</html>

