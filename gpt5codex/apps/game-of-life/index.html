<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game of Life Explorer</title>
    <style>
      :root {
        color-scheme: dark;
        --bg-gradient-start: #0f172a;
        --bg-gradient-end: #020617;
        --panel-bg: rgba(15, 23, 42, 0.82);
        --panel-border: rgba(148, 163, 184, 0.1);
        --text-primary: #e2e8f0;
        --text-muted: #94a3b8;
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --control-bg: rgba(30, 41, 59, 0.8);
        --control-border: rgba(148, 163, 184, 0.2);
        --control-hover: rgba(148, 163, 184, 0.25);
        --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.35);
      }

      html,
      body {
        height: 100%;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
        color: var(--text-primary);
      }

      #app {
        display: grid;
        grid-template-columns: minmax(240px, 320px) minmax(0, 1fr);
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }

      .controls-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 24px;
        background: var(--panel-bg);
        border-right: 1px solid var(--panel-border);
        backdrop-filter: blur(18px);
        overflow-y: auto;
        box-shadow: var(--shadow-soft);
      }

      .controls-panel h1 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
      }

      .controls-panel p.description {
        margin: 0;
        font-size: 14px;
        color: var(--text-muted);
        line-height: 1.5;
      }

      .controls-grid {
        display: grid;
        gap: 12px;
      }

      .controls-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        background: var(--control-bg);
        border: 1px solid var(--control-border);
        border-radius: 12px;
        box-shadow: var(--shadow-soft);
      }

      .controls-section h2 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      .controls-section p.note {
        margin: 0;
        font-size: 13px;
        color: var(--text-muted);
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      button.control-button {
        appearance: none;
        border: 1px solid var(--control-border);
        background: rgba(3, 7, 18, 0.4);
        color: var(--text-primary);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: transform 160ms ease, background 160ms ease, border-color 160ms ease;
      }

      button.control-button:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        background: rgba(56, 189, 248, 0.1);
      }

      button.control-button:active {
        transform: translateY(0);
        background: rgba(14, 165, 233, 0.22);
      }

      label.slider {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 13px;
      }

      label.slider span.value {
        font-weight: 600;
        color: var(--accent);
      }

      input[type="range"] {
        appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.25);
        overflow: hidden;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.35);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        border: none;
        cursor: pointer;
      }

      .canvas-stage {
        position: relative;
        overflow: hidden;
        background: radial-gradient(circle at top left, #1e293b 0%, #020617 80%);
      }

      .stage-inner {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas.render-surface {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script src="../../shared/ui.js"></script>
    <script src="../../shared/rendering.js"></script>
    <script>
      (function (global) {
        const {
          setupApp,
          createControlsSection,
          createButton,
          createSlider,
          createSelect,
          observeElementSize,
        } = global.MathWorldsUI;
        const { createRenderController } = global.MathWorldsRendering;

        const config = {
          columns: 64,
          rows: 48,
          running: false,
          speed: 6,
          renderMode: "euclidean",
          wrapMode: "none",
        };

        const state = {
          grid: new Set(),
          generation: 0,
          timer: null,
          dragMode: null,
        };

        const { controlStack, stageInner } = setupApp({
          title: "Game of Life Explorer",
          description: "Experiment with Conway's Game of Life. Tap cells to toggle, then run the simulation.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);

        const renderController = createRenderController(canvas, {
          background: "rgba(15, 23, 42, 0.95)",
        });
        renderController.setWrapMode(config.wrapMode);

        const offscreenCanvas = document.createElement("canvas");
        const offscreenCtx = offscreenCanvas.getContext("2d", { alpha: false });

        function keyFor(x, y) {
          return `${x},${y}`;
        }

        function getWrapFlags() {
          if (config.renderMode === "spherical") {
            return { wrapX: true, wrapY: true };
          }
          const wrapMode = config.wrapMode;
          return {
            wrapX: wrapMode === "horizontal" || wrapMode === "full",
            wrapY: wrapMode === "vertical" || wrapMode === "full",
          };
        }

        function normalizeCoordinates(x, y) {
          const { wrapX, wrapY } = getWrapFlags();
          if (wrapX) {
            x = ((x % config.columns) + config.columns) % config.columns;
          } else if (x < 0 || x >= config.columns) {
            return null;
          }

          if (wrapY) {
            y = ((y % config.rows) + config.rows) % config.rows;
          } else if (y < 0 || y >= config.rows) {
            return null;
          }

          return { x, y };
        }

        function locateCell(point) {
          const { cssWidth, cssHeight } = renderController.getState();
          const cellWidth = cssWidth / config.columns;
          const cellHeight = cssHeight / config.rows;
          if (!Number.isFinite(cellWidth) || !Number.isFinite(cellHeight) || cellWidth <= 0 || cellHeight <= 0) {
            return null;
          }
          const rawX = Math.floor(point.x / cellWidth);
          const rawY = Math.floor(point.y / cellHeight);
          return normalizeCoordinates(rawX, rawY);
        }

        function neighbors(x, y) {
          let count = 0;
          for (let dx = -1; dx <= 1; dx += 1) {
            for (let dy = -1; dy <= 1; dy += 1) {
              if (dx === 0 && dy === 0) continue;
              const coords = normalizeCoordinates(x + dx, y + dy);
              if (!coords) continue;
              if (state.grid.has(keyFor(coords.x, coords.y))) {
                count += 1;
              }
            }
          }
          return count;
        }

        function drawScene(targetCtx, { width, height }) {
          const pixelWidth = Math.max(1, Math.round(width));
          const pixelHeight = Math.max(1, Math.round(height));

          if (offscreenCanvas.width !== pixelWidth || offscreenCanvas.height !== pixelHeight) {
            offscreenCanvas.width = pixelWidth;
            offscreenCanvas.height = pixelHeight;
          }

          const ctx = offscreenCtx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, pixelWidth, pixelHeight);
          ctx.fillStyle = "rgba(15, 23, 42, 0.95)";
          ctx.fillRect(0, 0, pixelWidth, pixelHeight);

          const cellWidth = pixelWidth / config.columns;
          const cellHeight = pixelHeight / config.rows;

          ctx.strokeStyle = "rgba(148, 163, 184, 0.08)";
          ctx.lineWidth = 1;

          ctx.beginPath();
          for (let x = 1; x < config.columns; x += 1) {
            const px = x * cellWidth;
            ctx.moveTo(px, 0);
            ctx.lineTo(px, pixelHeight);
          }
          for (let y = 1; y < config.rows; y += 1) {
            const py = y * cellHeight;
            ctx.moveTo(0, py);
            ctx.lineTo(pixelWidth, py);
          }
          ctx.stroke();

          const paddingX = Math.min(2, cellWidth * 0.2);
          const paddingY = Math.min(2, cellHeight * 0.2);
          const drawWidth = Math.max(0, cellWidth - paddingX * 2);
          const drawHeight = Math.max(0, cellHeight - paddingY * 2);

          ctx.fillStyle = "#38bdf8";
          state.grid.forEach((key) => {
            const [cx, cy] = key.split(",").map(Number);
            const left = cx * cellWidth + paddingX;
            const top = cy * cellHeight + paddingY;
            ctx.fillRect(left, top, drawWidth, drawHeight);
          });

          ctx.fillStyle = "rgba(148, 163, 184, 0.65)";
          ctx.font = "14px 'JetBrains Mono', monospace";
          ctx.textBaseline = "bottom";
          ctx.fillText(`Generation ${state.generation}`, 12, pixelHeight - 12);

          targetCtx.drawImage(
            offscreenCanvas,
            0,
            0,
            pixelWidth,
            pixelHeight,
            0,
            0,
            width,
            height,
          );
        }

        function draw() {
          renderController.render((targetCtx, dimensions) => {
            drawScene(targetCtx, dimensions);
          });
        }

        function step() {
          const next = new Set();
          for (let x = 0; x < config.columns; x += 1) {
            for (let y = 0; y < config.rows; y += 1) {
              const alive = state.grid.has(keyFor(x, y));
              const count = neighbors(x, y);
              if (alive && (count === 2 || count === 3)) {
                next.add(keyFor(x, y));
              } else if (!alive && count === 3) {
                next.add(keyFor(x, y));
              }
            }
          }
          state.grid = next;
          state.generation += 1;
          draw();
        }

        function run() {
          if (!config.running) return;
          step();
          const delay = Math.max(16, 1200 / config.speed);
          state.timer = setTimeout(() => {
            requestAnimationFrame(run);
          }, delay);
        }

        function stop() {
          config.running = false;
          if (state.timer) {
            clearTimeout(state.timer);
            state.timer = null;
          }
        }

        function toggleRunning() {
          config.running = !config.running;
          if (config.running) {
            run();
            playPauseButton.textContent = "Pause";
          } else {
            stop();
            playPauseButton.textContent = "Play";
          }
        }

        function clearGrid() {
          stop();
          state.grid.clear();
          state.generation = 0;
          playPauseButton.textContent = "Play";
          draw();
        }

        function seedGlider() {
          clearGrid();
          state.grid.add(keyFor(1, 0));
          state.grid.add(keyFor(2, 1));
          state.grid.add(keyFor(0, 2));
          state.grid.add(keyFor(1, 2));
          state.grid.add(keyFor(2, 2));
          draw();
        }

        function seedRandom() {
          clearGrid();
          for (let x = 0; x < config.columns; x += 1) {
            for (let y = 0; y < config.rows; y += 1) {
              if (Math.random() < 0.2) {
                state.grid.add(keyFor(x, y));
              }
            }
          }
          draw();
        }

        let playPauseButton;

        const simulationControls = createControlsSection(
          "Simulation",
          "Play, pause, or step through generations.",
        );
        const buttonRow = document.createElement("div");
        buttonRow.className = "button-row";
        playPauseButton = createButton("Play", toggleRunning);
        const stepButton = createButton("Step", () => {
          if (!config.running) {
            step();
          }
        });
        const clearButton = createButton("Clear", clearGrid);
        buttonRow.appendChild(playPauseButton);
        buttonRow.appendChild(stepButton);
        buttonRow.appendChild(clearButton);
        simulationControls.appendChild(buttonRow);

        const speedSlider = createSlider({
          label: "Speed",
          min: 1,
          max: 12,
          value: config.speed,
          onChange: (value) => {
            config.speed = Number(value);
          },
        });
        simulationControls.appendChild(speedSlider.wrapper);
        controlStack.appendChild(simulationControls);

        const renderingSection = createControlsSection(
          "Rendering",
          "Switch between Euclidean and spherical projections. Right-drag in spherical mode to rotate.",
        );
        const wrapSelect = createSelect({
          label: "Euclidean Wraparound",
          options: [
            { value: "none", label: "None" },
            { value: "horizontal", label: "Left-Right" },
            { value: "vertical", label: "Up-Down" },
            { value: "full", label: "Full" },
          ],
          value: config.wrapMode,
          onChange: (value) => {
            config.wrapMode = value;
            renderController.setWrapMode(value);
            draw();
          },
        });
        const modeSelect = createSelect({
          label: "Rendering Mode",
          options: [
            { value: "euclidean", label: "Euclidean" },
            { value: "spherical", label: "Spherical" },
          ],
          value: config.renderMode,
          onChange: (value) => {
            config.renderMode = value;
            renderController.setMode(value);
            if (value === "spherical") {
              renderController.setWrapMode("full");
            } else {
              renderController.setWrapMode(config.wrapMode);
            }
            syncRenderingControls();
            draw();
          },
        });
        const resetRotationButton = createButton("Reset Rotation", () => {
          renderController.resetRotation();
          draw();
        });
        renderingSection.appendChild(modeSelect.wrapper);
        renderingSection.appendChild(wrapSelect.wrapper);
        renderingSection.appendChild(resetRotationButton);
        controlStack.appendChild(renderingSection);

        function syncRenderingControls() {
          modeSelect.select.value = config.renderMode;
          wrapSelect.select.value = config.wrapMode;
          const disabled = config.renderMode === "spherical";
          wrapSelect.select.disabled = disabled;
          wrapSelect.wrapper.style.opacity = disabled ? "0.6" : "";
        }

        syncRenderingControls();

        const seedsSection = createControlsSection("Seeds", "Start from classic or random patterns.");
        const seedButtons = document.createElement("div");
        seedButtons.className = "button-row";
        seedButtons.appendChild(createButton("Glider", seedGlider));
        seedButtons.appendChild(createButton("Random", seedRandom));
        seedsSection.appendChild(seedButtons);
        controlStack.appendChild(seedsSection);

        observeElementSize(stageInner, ({ width, height }) => {
          renderController.resize(width, height);
          draw();
        });

        renderController.onChange(draw);

        canvas.addEventListener("pointerdown", (event) => {
          if (event.button !== 0) return;
          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const coords = locateCell(point);
          if (!coords) return;
          event.preventDefault();
          const key = keyFor(coords.x, coords.y);
          const alive = state.grid.has(key);
          state.dragMode = alive ? "erase" : "paint";
          if (alive) {
            state.grid.delete(key);
          } else {
            state.grid.add(key);
          }
          draw();
          canvas.setPointerCapture(event.pointerId);
        });

        canvas.addEventListener("pointermove", (event) => {
          if (!state.dragMode) return;
          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const coords = locateCell(point);
          if (!coords) return;
          const key = keyFor(coords.x, coords.y);
          if (state.dragMode === "paint") {
            if (!state.grid.has(key)) {
              state.grid.add(key);
              draw();
            }
          } else if (state.dragMode === "erase") {
            if (state.grid.delete(key)) {
              draw();
            }
          }
        });

        function endPaint(event) {
          if (state.dragMode && canvas.hasPointerCapture && canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
          }
          state.dragMode = null;
        }

        canvas.addEventListener("pointerup", endPaint);
        canvas.addEventListener("pointercancel", endPaint);
        canvas.addEventListener("pointerleave", endPaint);

        draw();
      })(window);
    </script>
  </body>
</html>

