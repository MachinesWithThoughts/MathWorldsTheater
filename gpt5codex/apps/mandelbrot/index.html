<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Set Explorer</title>
    <link rel="stylesheet" href="../../shared/base.css" />
  </head>
  <body>
    <div id="app"></div>
    <script src="../../shared/ui.js"></script>
    <script src="../../shared/rendering.js"></script>
    <script>
      (function (global) {
        const {
          setupApp,
          createControlsSection,
          createButton,
          createSlider,
          createSelect,
          createStatusPill,
          observeElementSize,
        } = global.MathWorldsUI;
        const { createRenderController } = global.MathWorldsRendering;

        const params = {
          centerX: -0.5,
          centerY: 0,
          scale: 3,
          maxIterations: 200,
        };

        const state = {
          width: 800,
          height: 600,
          boundingBox: null,
          dragging: false,
          dragStart: null,
          dragEnd: null,
          renderMode: "euclidean",
          wrapMode: "none",
        };

        const { controlStack, stageInner } = setupApp({
          title: "Mandelbrot Set Explorer",
          description: "Zoom and pan around the Mandelbrot set. Drag to preview a bounding box before zooming.",
        });

        const canvas = document.createElement("canvas");
        canvas.className = "render-surface";
        stageInner.appendChild(canvas);

        const renderController = createRenderController(canvas, {
          background: "rgba(2, 6, 23, 0.94)",
        });
        renderController.setWrapMode(state.wrapMode);

        const offscreenCanvas = document.createElement("canvas");
        const ctx = offscreenCanvas.getContext("2d", { alpha: false });

        function colorize(iteration, maxIterations) {
          if (iteration >= maxIterations) {
            return [12, 20, 33];
          }

          const t = iteration / maxIterations;
          const r = Math.floor(9 * (1 - t) * t * t * t * 255);
          const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
          const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
          return [r, g, b];
        }

        function renderMandelbrot(bufferWidth, bufferHeight) {
          const image = ctx.createImageData(bufferWidth, bufferHeight);
          const data = image.data;
          const maxIterations = params.maxIterations;

          for (let y = 0; y < bufferHeight; y += 1) {
            const cy = params.centerY + (y / bufferHeight - 0.5) * params.scale;
            for (let x = 0; x < bufferWidth; x += 1) {
              const cx = params.centerX +
                (x / bufferWidth - 0.5) * params.scale * (bufferWidth / bufferHeight);
              let zx = 0;
              let zy = 0;
              let iteration = 0;
              while (zx * zx + zy * zy <= 4 && iteration < maxIterations) {
                const xtemp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = xtemp;
                iteration += 1;
              }

              const [r, g, b] = colorize(iteration, maxIterations);
              const index = (y * bufferWidth + x) * 4;
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = 255;
            }
          }

          ctx.putImageData(image, 0, 0);
        }

        function screenToComplex(point) {
          return {
            x: params.centerX + (point.x / state.width - 0.5) * params.scale * (state.width / state.height),
            y: params.centerY + (point.y / state.height - 0.5) * params.scale,
          };
        }

        function handleZoomBox(start, end) {
          const minX = Math.min(start.x, end.x);
          const minY = Math.min(start.y, end.y);
          const maxX = Math.max(start.x, end.x);
          const maxY = Math.max(start.y, end.y);

          const startComplex = screenToComplex({ x: minX, y: minY });
          const endComplex = screenToComplex({ x: maxX, y: maxY });

          params.centerX = (startComplex.x + endComplex.x) / 2;
          params.centerY = (startComplex.y + endComplex.y) / 2;
          params.scale = Math.max(
            Math.abs(endComplex.x - startComplex.x),
            Math.abs(endComplex.y - startComplex.y) * (state.width / state.height),
          );
        }

        function drawBoundingBox(targetCtx, start, end) {
          const minX = Math.min(start.x, end.x);
          const minY = Math.min(start.y, end.y);
          const maxX = Math.max(start.x, end.x);
          const maxY = Math.max(start.y, end.y);

          targetCtx.save();
          targetCtx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          targetCtx.setLineDash([6, 4]);
          targetCtx.lineWidth = 2;
          targetCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);
          targetCtx.restore();
        }

        canvas.addEventListener("pointerdown", (event) => {
          const point = renderController.mapEventToScene(event);
          if (!point) return;

          state.dragging = true;
          state.dragStart = point;
          state.dragEnd = point;
          state.boundingBox = { start: point, end: point };
        });

        canvas.addEventListener("pointermove", (event) => {
          if (!state.dragging) return;
          const point = renderController.mapEventToScene(event);
          if (!point) return;

          state.dragEnd = point;
          state.boundingBox = { start: state.dragStart, end: point };
        });

        canvas.addEventListener("pointerup", () => {
          if (state.dragging && state.dragStart && state.dragEnd) {
            handleZoomBox(state.dragStart, state.dragEnd);
          }
          state.dragging = false;
          state.dragStart = null;
          state.dragEnd = null;
          state.boundingBox = null;
          requestRender();
        });

        canvas.addEventListener("pointerleave", () => {
          if (state.dragging) {
            state.dragging = false;
            state.dragStart = null;
            state.dragEnd = null;
            state.boundingBox = null;
            requestRender();
          }
        });

        canvas.addEventListener("wheel", (event) => {
          event.preventDefault();
          const point = renderController.mapEventToScene(event);
          if (!point) return;
          const zoomFactor = event.deltaY < 0 ? 0.8 : 1.25;
          const pointComplex = screenToComplex(point);
          params.centerX = pointComplex.x + (params.centerX - pointComplex.x) * zoomFactor;
          params.centerY = pointComplex.y + (params.centerY - pointComplex.y) * zoomFactor;
          params.scale *= zoomFactor;
          requestRender();
        }, { passive: false });

        function resetView() {
          params.centerX = -0.5;
          params.centerY = 0;
          params.scale = 3;
          requestRender();
        }

        const viewControlsSection = createControlsSection("View", "Modify iterations and reset the viewport.");
        const viewControls = viewControlsSection.element;
        const iterationSlider = createSlider({
          label: "Max Iterations",
          min: 50,
          max: 600,
          step: 10,
          value: params.maxIterations,
          onChange: (value) => {
            params.maxIterations = Number(value);
            requestRender();
          },
        });
        viewControlsSection.appendChild(iterationSlider.wrapper);
        viewControlsSection.appendChild(createButton("Reset View", resetView));
        controlStack.appendChild(viewControls);

        const renderingSectionWrapper = createControlsSection(
          "Rendering",
          "Switch between Euclidean and spherical projections. Right-drag in spherical mode to rotate.",
        );
        const renderingSection = renderingSectionWrapper.element;
        const modeSelect = createSelect({
          label: "Mode",
          options: [
            { value: "euclidean", label: "Euclidean" },
            { value: "spherical", label: "Spherical" },
          ],
          value: state.renderMode,
          onChange: (value) => {
            state.renderMode = value;
            renderController.setMode(value);
            if (value === "spherical") {
              renderController.setWrapMode("full");
            } else {
              renderController.setWrapMode(state.wrapMode);
            }
            syncRenderingControls();
            requestRender();
          },
        });
        const wrapSelect = createSelect({
          label: "Euclidean Wrap",
          options: [
            { value: "none", label: "None" },
            { value: "horizontal", label: "Left-Right" },
            { value: "vertical", label: "Up-Down" },
            { value: "full", label: "Full" },
          ],
          value: state.wrapMode,
          onChange: (value) => {
            state.wrapMode = value;
            renderController.setWrapMode(value);
            requestRender();
          },
        });
        const resetRotationButton = createButton("Reset Rotation", () => {
          renderController.resetRotation();
          requestRender();
        });
        renderingSectionWrapper.appendChild(modeSelect.wrapper);
        renderingSectionWrapper.appendChild(wrapSelect.wrapper);
        renderingSectionWrapper.appendChild(resetRotationButton);
        controlStack.appendChild(renderingSection);

        function syncRenderingControls() {
          modeSelect.select.value = state.renderMode;
          wrapSelect.select.value = state.wrapMode;
          const disabled = state.renderMode === "spherical";
          wrapSelect.select.disabled = disabled;
          wrapSelect.wrapper.style.opacity = disabled ? "0.6" : "";
        }

        syncRenderingControls();

        const statusSectionWrapper = createControlsSection("Status", "Current center and scale.", { collapsed: true });
        const statusSection = statusSectionWrapper.element;
        const statusPill = createStatusPill("");
        statusSectionWrapper.appendChild(statusPill);
        controlStack.appendChild(statusSection);

        function updateStatus() {
          statusPill.textContent = `Center (${params.centerX.toFixed(4)}, ${params.centerY.toFixed(4)}) • Scale ${params.scale.toFixed(3)}`;
        }

        let pendingRender = false;
        function requestRender() {
          if (pendingRender) return;
          pendingRender = true;
          requestAnimationFrame(() => {
            pendingRender = false;
            renderController.render((targetCtx, { width, height }) => {
              const bufferWidth = Math.max(1, Math.round(width));
              const bufferHeight = Math.max(1, Math.round(height));

              if (offscreenCanvas.width !== bufferWidth || offscreenCanvas.height !== bufferHeight) {
                offscreenCanvas.width = bufferWidth;
                offscreenCanvas.height = bufferHeight;
              }

              state.width = bufferWidth;
              state.height = bufferHeight;

              renderMandelbrot(bufferWidth, bufferHeight);
              targetCtx.drawImage(offscreenCanvas, 0, 0, bufferWidth, bufferHeight, 0, 0, width, height);

              if (state.boundingBox) {
                drawBoundingBox(targetCtx, state.boundingBox.start, state.boundingBox.end);
              }
            });
            updateStatus();
          });
        }

        observeElementSize(stageInner, ({ width, height }) => {
          renderController.resize(width, height);
          requestRender();
        });

        setInterval(updateStatus, 300);
        renderController.onChange(requestRender);

        requestRender();
      })(window);
    </script>
  </body>
</html>

